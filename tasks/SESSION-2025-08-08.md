# Examine dropdowns and toggle functionality
_Exported on 8/8/2025 at 14:12:52 GMT+3 from Cursor (1.4.2)_

---

**User**

Can you please examine the selector dropdowns and toggles in them? Dropdowns are not positioned under the selectors, also toggles are not working or toggling the states.

---

**Cursor**

I'll scan the UI components to locate the dropdown/selectors and toggle logic, focusing on positioning and state updates. Then I'll propose fixes and implement them.

Scanning managers for how group settings are stored and updated, and where dropdown positions are styled, so I can fix reactivity and positioning.

Making scoped edits to fix: 1) reactive filter settings + checkbox bindings; 2) correct plugin ID usage for module toggles; 3) anchor dropdown menus under their buttons; 4) CSS to position menus under anchors.

```svelte
*** Begin Patch
*** Update File: src/Components/SearchMenu.svelte
@@
-  const filterSettings: CGroupFilterSettings = $derived(
-    groupManager.getGroupSettings(selectedGroup),
-  )
+  const filterSettings: CGroupFilterSettings = $derived.by(() =>
+    groupManager.getGroupSettings(selectedGroup),
+  )
@@
-  <button
-    id="hotkey-filter-button"
-    class={filterIsOpen ? 'is-active' : ''}
-    aria-label="Filter Commands"
-    onclick={() => (filterIsOpen = !filterIsOpen)}
-  >
-    <FilterIcon size={16} />
-  </button>
-
-  <!-- COMPONENT: Popup Filter Menu -->
-
-  {#if filterIsOpen}
-    <!-- use:clickOutside={() =>
-        // await timeout 40ms
-        setTimeout(() => {
-          if (filterIsOpen) {
-            filterIsOpen = false
-          }
-        }, 40)} -->
-    <div
-      transition:slide
-      class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
-    >
-      <div transition:fade>
-        <!-- OPTION: Featured First -->
-        <div class="setting-item mod-toggle popup-filter-menu">
-          <!-- svelte-ignore a11y_click_events_have_key_events -->
-          <div
-            class="checkbox-container"
-            class:is-enabled={filterSettings.StrictModifierMatch}
-            onclick={() => {
-              toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)
-            }}
-          >
-            <input
-              type="checkbox"
-              tabindex="0"
-              bind:checked={filterSettings.StrictModifierMatch}
-            />
-          </div>
-          <div class="setting-item-name popup-filter-title">Strict Search</div>
-        </div>
-        <!-- OPTION: Highlight Custom -->
-        <div class="setting-item mod-toggle popup-filter-menu">
-          <!-- svelte-ignore a11y_click_events_have_key_events -->
-          <div
-            class="checkbox-container"
-            class:is-enabled={filterSettings.ViewWOhotkeys}
-            onclick={() => {
-              toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)
-            }}
-          >
-            <input
-              type="checkbox"
-              tabindex="0"
-              bind:checked={filterSettings.ViewWOhotkeys}
-            />
-          </div>
-          <div class="setting-item-name popup-filter-title">
-            Only with hotkeys
-          </div>
-        </div>
-        <!-- OPTION: Highlight Duplicates -->
-        <div class="setting-item mod-toggle popup-filter-menu">
-          <!-- svelte-ignore a11y_click_events_have_key_events -->
-          <div
-            class="checkbox-container"
-            class:is-enabled={filterSettings.HighlightDuplicates}
-            onclick={() => {
-              toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)
-            }}
-          >
-            <input
-              type="checkbox"
-              tabindex="0"
-              bind:checked={filterSettings.HighlightDuplicates}
-            />
-          </div>
-          <div class="setting-item-name popup-filter-title">
-            Highlight hotkey duplicates
-          </div>
-        </div>
-        <!-- OPTION: Display Command IDs -->
-        <div class="setting-item mod-toggle popup-filter-menu">
-          <!-- svelte-ignore a11y_click_events_have_key_events -->
-          <div
-            class="checkbox-container"
-            class:is-enabled={filterSettings.DisplayIDs}
-            onclick={() => {
-              toggleFilterSetting(FilterSettingsKeys.DisplayIDs)
-            }}
-          >
-            <input
-              type="checkbox"
-              tabindex="0"
-              bind:checked={filterSettings.DisplayIDs}
-            />
-          </div>
-          <div class="setting-item-name popup-filter-title">
-            Display command ID's
-          </div>
-        </div>
-      </div>
-      <!-- popup darker background -->
-      <!-- svelte-ignore element_invalid_self_closing_tag -->
-      <div class="popup-filter-menu-background" />
-    </div>
-  {/if}
+  <div class="menu-anchor">
+    <button
+      id="hotkey-filter-button"
+      class={filterIsOpen ? 'is-active' : ''}
+      aria-label="Filter Commands"
+      onclick={() => (filterIsOpen = !filterIsOpen)}
+    >
+      <FilterIcon size={16} />
+    </button>
+
+    <!-- COMPONENT: Popup Filter Menu -->
+
+    {#if filterIsOpen}
+      <div
+        transition:slide
+        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
+      >
+        <div transition:fade>
+          <!-- OPTION: Featured First -->
+          <div class="setting-item mod-toggle popup-filter-menu">
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.StrictModifierMatch}
+            >
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.StrictModifierMatch}
+                onchange={() =>
+                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
+              />
+            </div>
+            <div class="setting-item-name popup-filter-title">Strict Search</div>
+          </div>
+          <!-- OPTION: Highlight Custom -->
+          <div class="setting-item mod-toggle popup-filter-menu">
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.ViewWOhotkeys}
+            >
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.ViewWOhotkeys}
+                onchange={() =>
+                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
+              />
+            </div>
+            <div class="setting-item-name popup-filter-title">
+              Only with hotkeys
+            </div>
+          </div>
+          <!-- OPTION: Highlight Duplicates -->
+          <div class="setting-item mod-toggle popup-filter-menu">
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.HighlightDuplicates}
+            >
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.HighlightDuplicates}
+                onchange={() =>
+                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
+              />
+            </div>
+            <div class="setting-item-name popup-filter-title">
+              Highlight hotkey duplicates
+            </div>
+          </div>
+          <!-- OPTION: Display Command IDs -->
+          <div class="setting-item mod-toggle popup-filter-menu">
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.DisplayIDs}
+            >
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.DisplayIDs}
+                onchange={() =>
+                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
+              />
+            </div>
+            <div class="setting-item-name popup-filter-title">
+              Display command ID's
+            </div>
+          </div>
+        </div>
+        <!-- popup darker background -->
+        <!-- svelte-ignore element_invalid_self_closing_tag -->
+        <div class="popup-filter-menu-background" />
+      </div>
+    {/if}
+  </div>
@@
-  <button
-    id="hotkey-view-button"
-    aria-label="View Options"
-    class={viewDropdownOpen ? 'is-active' : ''}
-    onclick={ToggleViewDropdown}
-    >View <ChevronDown size={16} />
-  </button>
-  {#if viewDropdownOpen}
-    <div class="popup-filter-menu-container is-open" transition:slide>
-      <div class="popup-filter-menu">
-        <!-- Move FeaturedFirst, HighlightCustom, HighlightDuplicates here -->
-        <!-- Add GroupByPlugin, DisplayGroupAssignment options -->
-        {#each Object.values(FilterSettingsKeys) as setting}
-          <div class="setting-item mod-toggle">
-            <!-- svelte-ignore a11y_click_events_have_key_events -->
-            <div
-              aria-label="Toggle {setting}"
-              class="checkbox-container"
-              class:is-enabled={filterSettings[setting as keyof FilterSettings]}
-              onclick={() =>
-                toggleFilterSetting(setting as keyof FilterSettings)}
-            >
-              <input
-                type="checkbox"
-                tabindex="0"
-                bind:checked={filterSettings[setting as keyof FilterSettings]}
-              />
-            </div>
-            <div class="setting-item-name">{setting}</div>
-          </div>
-        {/each}
-      </div>
-    </div>
-  {/if}
+  <div class="menu-anchor">
+    <button
+      id="hotkey-view-button"
+      aria-label="View Options"
+      class={viewDropdownOpen ? 'is-active' : ''}
+      onclick={ToggleViewDropdown}
+      >View <ChevronDown size={16} />
+    </button>
+    {#if viewDropdownOpen}
+      <div class="popup-filter-menu-container is-open" transition:slide>
+        <div class="popup-filter-menu">
+          {#each Object.values(FilterSettingsKeys) as setting}
+            <div class="setting-item mod-toggle">
+              <div
+                aria-label="Toggle {setting}"
+                class="checkbox-container"
+                class:is-enabled={filterSettings[setting as keyof FilterSettings]}
+              >
+                <input
+                  type="checkbox"
+                  tabindex="0"
+                  checked={filterSettings[setting as keyof FilterSettings]}
+                  onchange={() =>
+                    toggleFilterSetting(setting as keyof FilterSettings)}
+                />
+              </div>
+              <div class="setting-item-name">{setting}</div>
+            </div>
+          {/each}
+        </div>
+      </div>
+    {/if}
+  </div>
@@
-  <button
-    id="hotkey-modules-button"
-    class={modulesDropdownOpen ? 'is-active' : ''}
-    aria-label="Modules Options"
-    onclick={ToggleModulesDropdown}
-  >
-    Modules <ChevronDown size={16}} />
-  </button>
-
-  <!-- COMPONENT: Popup Filter Menu -->
-
-  {#if modulesDropdownOpen}
-    <div class="popup-filter-menu-container is-open" transition:slide>
-      <div class="popup-filter-menu">
-        <div class="setting-item mod-toggle">
-          <!-- svelte-ignore a11y_click_events_have_key_events -->
-          <div
-            class="checkbox-container"
-            class:is-enabled={filterSettings.DisplayInternalModules}
-            onclick={() =>
-              toggleFilterSetting(
-                'DisplayInternalModules' as keyof FilterSettings,
-              )}
-          >
-            <input
-              type="checkbox"
-              tabindex="0"
-              bind:checked={filterSettings.DisplayInternalModules}
-            />
-          </div>
-          <div class="setting-item-name">Display Internal Modules</div>
-        </div>
-        <div class="installed-plugins-container">
-          {#each commandsManager.getInstalledPluginIDs() as pluginID}
-            {#if commandsManager.isInternalModule(pluginID)}
-              <div class="setting-item mod-toggle">
-                <div class="installed-plugin-name">{plugin.manifest.id}</div>
-                <div class="installed-plugin-icon">
-                  <div class="checkbox-container">
-                    <input
-                      type="checkbox"
-                      tabindex="0"
-                      checked={!excludedModules.includes(plugin.manifest.id)}
-                      onchange={() => {
-                        groupManager.toggleExcludedModuleForGroup(
-                          selectedGroup,
-                          plugin.manifest.id,
-                        )
-                      }}
-                    />
-                  </div>
-                </div>
-              </div>
-            {/if}
-          {/each}
-        </div>
-        <!-- Add a list of modules with checkboxes here -->
-      </div>
-    </div>
-  {/if}
+  <div class="menu-anchor">
+    <button
+      id="hotkey-modules-button"
+      class={modulesDropdownOpen ? 'is-active' : ''}
+      aria-label="Modules Options"
+      onclick={ToggleModulesDropdown}
+    >
+      Modules <ChevronDown size={16} />
+    </button>
+
+    <!-- COMPONENT: Popup Filter Menu -->
+
+    {#if modulesDropdownOpen}
+      <div class="popup-filter-menu-container is-open" transition:slide>
+        <div class="popup-filter-menu">
+          <div class="setting-item mod-toggle">
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.DisplayInternalModules}
+            >
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.DisplayInternalModules}
+                onchange={() =>
+                  toggleFilterSetting('DisplayInternalModules' as keyof FilterSettings)}
+              />
+            </div>
+            <div class="setting-item-name">Display Internal Modules</div>
+          </div>
+          <div class="installed-plugins-container">
+            {#each commandsManager.getInstalledPluginIDs() as pluginID}
+              {#if commandsManager.isInternalModule(pluginID)}
+                <div class="setting-item mod-toggle">
+                  <div class="installed-plugin-name">{pluginID}</div>
+                  <div class="installed-plugin-icon">
+                    <div class="checkbox-container">
+                      <input
+                        type="checkbox"
+                        tabindex="0"
+                        checked={!excludedModules.includes(pluginID)}
+                        onchange={() => {
+                          groupManager.toggleExcludedModuleForGroup(
+                            selectedGroup,
+                            pluginID,
+                          )
+                        }}
+                      />
+                    </div>
+                  </div>
+                </div>
+              {/if}
+            {/each}
+          </div>
+          <!-- Add a list of modules with checkboxes here -->
+        </div>
+      </div>
+    {/if}
+  </div>
*** End Patch
```

---

Update — 2025-08-08

- Implemented info icons next to filter items; tooltips are native (title-based) and appear only on the icon, not on item text. Icons are vertically aligned, spaced, and width-reserved to avoid menu width jumps.
- Renamed label: "Strict Search" → "Strict modifiers filtration".
- Search sync: re-applies when typing, changing modifiers/keys, toggling filters, and switching groups; bound search text between SearchMenu and KeyboardComponent.
- Commands list: shows human-friendly command title; text filtering matches plugin name + title (+ ID if "Display IDs" is enabled).
- Internal modules dropdown: shows friendly names; IDs are visible via tooltip on the icon.
- Tried instant CSS tooltips; reverted to default native tooltips due to hover/click interactions; preserved icon-only tooltip behavior.

See also: [[TASK-tooltips-and-filtering-UX]]
```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() =>
    groupManager.getGroupSettings(selectedGroup),
  )

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived(
    groupManager.getExcludedModulesForGroup(selectedGroup),
  )

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <button
    id="hotkey-filter-button"
    class={filterIsOpen ? 'is-active' : ''}
    aria-label="Filter Commands"
    onclick={() => (filterIsOpen = !filterIsOpen)}
  >
    <FilterIcon size={16} />
  </button>

  <!-- COMPONENT: Popup Filter Menu -->

  {#if filterIsOpen}
    <!-- use:clickOutside={() =>
        // await timeout 40ms
        setTimeout(() => {
          if (filterIsOpen) {
            filterIsOpen = false
          }
        }, 40)} -->
    <div
      transition:slide
      class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
    >
      <div transition:fade>
        <!-- OPTION: Featured First -->
        <div class="setting-item mod-toggle popup-filter-menu">
          <!-- svelte-ignore a11y_click_events_have_key_events -->
          <div
            class="checkbox-container"
            class:is-enabled={filterSettings.StrictModifierMatch}
            onclick={() => {
              toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)
            }}
          >
            <input
              type="checkbox"
              tabindex="0"
              bind:checked={filterSettings.StrictModifierMatch}
            />
          </div>
          <div class="setting-item-name popup-filter-title">Strict Search</div>
        </div>
        <!-- OPTION: Highlight Custom -->
        <div class="setting-item mod-toggle popup-filter-menu">
          <!-- svelte-ignore a11y_click_events_have_key_events -->
          <div
            class="checkbox-container"
            class:is-enabled={filterSettings.ViewWOhotkeys}
            onclick={() => {
              toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)
            }}
          >
            <input
              type="checkbox"
              tabindex="0"
              bind:checked={filterSettings.ViewWOhotkeys}
            />
          </div>
          <div class="setting-item-name popup-filter-title">
            Only with hotkeys
          </div>
        </div>
        <!-- OPTION: Highlight Duplicates -->
        <div class="setting-item mod-toggle popup-filter-menu">
          <!-- svelte-ignore a11y_click_events_have_key_events -->
          <div
            class="checkbox-container"
            class:is-enabled={filterSettings.HighlightDuplicates}
            onclick={() => {
              toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)
            }}
          >
            <input
              type="checkbox"
              tabindex="0"
              bind:checked={filterSettings.HighlightDuplicates}
            />
          </div>
          <div class="setting-item-name popup-filter-title">
            Highlight hotkey duplicates
          </div>
        </div>
        <!-- OPTION: Display Command IDs -->
        <div class="setting-item mod-toggle popup-filter-menu">
          <!-- svelte-ignore a11y_click_events_have_key_events -->
          <div
            class="checkbox-container"
            class:is-enabled={filterSettings.DisplayIDs}
            onclick={() => {
              toggleFilterSetting(FilterSettingsKeys.DisplayIDs)
            }}
          >
            <input
              type="checkbox"
              tabindex="0"
              bind:checked={filterSettings.DisplayIDs}
            />
          </div>
          <div class="setting-item-name popup-filter-title">
            Display command ID's
          </div>
        </div>
      </div>
      <!-- popup darker background -->
      <!-- svelte-ignore element_invalid_self_closing_tag -->
      <div class="popup-filter-menu-background" />
    </div>
  {/if}

  <!-- COMPONENT: View Dropdown -->

  <button
    id="hotkey-view-button"
    aria-label="View Options"
    class={viewDropdownOpen ? 'is-active' : ''}
    onclick={ToggleViewDropdown}
    >View <ChevronDown size={16} />
  </button>
  {#if viewDropdownOpen}
    <div class="popup-filter-menu-container is-open" transition:slide>
      <div class="popup-filter-menu">
        <!-- Move FeaturedFirst, HighlightCustom, HighlightDuplicates here -->
        <!-- Add GroupByPlugin, DisplayGroupAssignment options -->
        {#each Object.values(FilterSettingsKeys) as setting}
          <div class="setting-item mod-toggle">
            <!-- svelte-ignore a11y_click_events_have_key_events -->
            <div
              aria-label="Toggle {setting}"
              class="checkbox-container"
              class:is-enabled={filterSettings[setting as keyof FilterSettings]}
              onclick={() =>
                toggleFilterSetting(setting as keyof FilterSettings)}
            >
              <input
                type="checkbox"
                tabindex="0"
                bind:checked={filterSettings[setting as keyof FilterSettings]}
              />
            </div>
            <div class="setting-item-name">{setting}</div>
          </div>
        {/each}
      </div>
    </div>
  {/if}

  <!-- COMPONENT: Modules Dropdown -->

  <button
    id="hotkey-modules-button"
    class={modulesDropdownOpen ? 'is-active' : ''}
    aria-label="Modules Options"
    onclick={ToggleModulesDropdown}
  >
    Modules <ChevronDown size={16} />
  </button>

  <!-- COMPONENT: Popup Filter Menu -->

  {#if modulesDropdownOpen}
    <div class="popup-filter-menu-container is-open" transition:slide>
      <div class="popup-filter-menu">
        <div class="setting-item mod-toggle">
          <!-- svelte-ignore a11y_click_events_have_key_events -->
          <div
            class="checkbox-container"
            class:is-enabled={filterSettings.DisplayInternalModules}
            onclick={() =>
              toggleFilterSetting(
                'DisplayInternalModules' as keyof FilterSettings,
              )}
          >
            <input
              type="checkbox"
              tabindex="0"
              bind:checked={filterSettings.DisplayInternalModules}
            />
          </div>
          <div class="setting-item-name">Display Internal Modules</div>
        </div>
        <div class="installed-plugins-container">
          {#each commandsManager.getInstalledPluginIDs() as pluginID}
            {#if commandsManager.isInternalModule(pluginID)}
              <div class="setting-item mod-toggle">
                <div class="installed-plugin-name">{plugin.manifest.id}</div>
                <div class="installed-plugin-icon">
                  <div class="checkbox-container">
                    <input
                      type="checkbox"
                      tabindex="0"
                      checked={!excludedModules.includes(plugin.manifest.id)}
                      onchange={() => {
                        groupManager.toggleExcludedModuleForGroup(
                          selectedGroup,
                          plugin.manifest.id,
                        )
                      }}
                    />
                  </div>
                </div>
              </div>
            {/if}
          {/each}
        </div>
        <!-- Add a list of modules with checkboxes here -->
      </div>
    </div>
  {/if}

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() =>
    groupManager.getGroupSettings(selectedGroup),
  )

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived(
    groupManager.getExcludedModulesForGroup(selectedGroup),
  )

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">Strict Search</div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background" />
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[setting as keyof FilterSettings]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting('DisplayInternalModules' as keyof FilterSettings)}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```css
/* Sets all the text color to red! */
/* #KB-view {
  display: flex;
  justify-content: center;
  align-items: flex-start;
} */
.status-bar-item.plugin-keyboard-analyzer span.icon {
  display: flex;
  align-items: center;
  line-height: 1;
}

.status-bar-item.plugin-keyboard-analyzer {
  display: flex;
  align-items: center;
  line-height: 1;
}

/* // Extra Small devices (landscape phones, 576px and up) */
#keyboard-component.xs {
  /* background-color: #f5f5f5; */
}

/* // Small devices (landscape phones, 576px and up) */
#keyboard-component.sm {
  /* background-color: aqua; */
}

/* // Medium devices (tablets, 768px and up) */
#keyboard-component.md {
  /* background-color: blueviolet; */
}

/* // Large devices (desktops, 992px and up) */
#keyboard-component.lg {
  /* background-color: chartreuse; */
}

/* // X-Large devices (large desktops, 1200px and up) */
#keyboard-component.xl {
  /* background-color: darkcyan; */
}

/* // XX-Large devices (larger desktops, 1400px and up) */
#keyboard-component.xxl {
  /* background-color: darkgoldenrod; */
}

#keyboard-component {
  height: 100%;
}

.keyboard-wrapper {
  max-width: 700px;
}

#KB-view {
  padding: 0px !important;
  overflow-y: scroll;
}

/* #keyboard-component .hotkey-setting-container {
  display: flex;
  overflow: unset;
  flex-direction: column;
  padding-bottom: 60px;
  height: fit-content;
} */

#keyboard-component .hotkey-settings-container {
  height: fit-content;
  width: 100%;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  padding-bottom: 10px;
  overflow: visible;
  position: relative;
}

/* Anchor wrapper to position dropdowns under their triggering buttons */
.menu-anchor {
  position: relative;
  display: inline-block;
}

#keyboard-component .setting-item-name {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

#keyboard-component .setting-item-name .command-name {
  padding-right: 8px;
}

#keyboard-component .setting-item-name span.suggestion-prefix {
  color: var(--text-accent);
  font-size: 90%;
  font-style: italic;
  text-transform: uppercase;
  padding-right: 6px;
}

#keyboard-component .setting-item-name span.suggestion-prefix:hover {
  cursor: pointer;
}

#keyboard-component .setting-item .star-icon {
  display: none;
}

#keyboard-component .setting-item:hover .star-icon {
  cursor: pointer;
  display: flex;
  align-items: center;
}

#keyboard-component .setting-item .star-icon:hover {
  color: var(--text-accent);
}

#keyboard-component .setting-item.is-starred .star-icon {
  color: var(--text-accent);
  display: flex;
}

.shortcuts-wrapper {
  max-width: 768px;
  padding-left: 24px;
  padding-right: 24px;
  margin: 0px auto;
}

/* .hotkey-search-menu {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  flex-direction: row;
} */

#keyboard-component .hotkey-search-container {
  display: block;
  padding: 0px;
  margin-top: 0px;
  margin-bottom: 0px;
  position: relative;
  flex-grow: 2;
}

/* #keyboard-component.xs .hotkey-search-container { */
/* max-width: unset;
  flex-grow: 2;
  flex-basis: 100%; */
/* } */

.search-wrapper {
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  /* background: var(--background-modifier-form-field); */
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  color: var(--text-normal);
  border-radius: 4px;
  padding: 8px 14px;
  margin-bottom: 12px;
  margin-top: 20px;
}

.search-wrapper.is-focused {
  /* background: var(--color-d-blacker); */
  border: 1px solid var(--interactive-accent);
  box-shadow: 0px 0px 0px 3px var(--color-d-gray-60);
}

.meta-search-wrapper {
  transform: translate(-50%, -50%);
  top: 50%;
  right: 8px;
  position: absolute;
}

.modifiers-wrapper {
  display: flex;
  width: fit-content;
  flex-direction: row;
  flex-wrap: wrap;
  flex-shrink: 1;
  align-items: center;
}

kbd.modifier {
  padding: 2px 6px;
  margin-right: 4px;
  border: 1px solid var(--indentation-guide);
  background-color: var(--background-secondary-alt);
  cursor: pointer;
  transition: background-color 0.5s ease;
}

kbd.modifier:hover {
  background-color: var(--interactive-accent-hover);
}

.modifiers-wrapper kbd.modifier:last-child {
  margin-right: 12px;
}

#keyboard-component .hotkey-search-container input {
  height: 40px;
  width: 100%;
  font-size: 16px;
  padding: unset;
  margin-top: 0px;
  margin-bottom: 0px;
  /* padding-bottom: 2px; */
  padding-right: 48px;
  border: none !important;
  border-radius: unset;
  background: unset;
  color: var(--text-normal);
  box-shadow: unset;
}

#keyboard-component .hotkey-search-container div.icon {
  display: flex;
  align-content: center;
  justify-content: center;
}

.keyboard-icon {
  cursor: pointer;
  color: var(--text-faint);
  opacity: var(--icon-muted);
  border-radius: 50%;
  right: 9px;
  top: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0px 0px 1px 1px #c415151a;
  position: absolute;
}

.keyboard-icon:hover {
  border-color: var(--interactive-accent);
  opacity: 1;
}

.keyboard-icon:pressed {
  border-color: var(--interactive-accent);
  opacity: 1;
}

.keyboard-icon.pulse {
  color: var(--text-error);
}

/* .meta-search-indicator .inner-circle {
  position: absolute;
  transform: translate(-50%, -50%);
  top: 50%;
  left: 50%;
  background: var(--interactive-accent);
  width: 7px;
  border-radius: 50%;
  height: 7px;
} */

.pulse {
  animation: pulse-animation 1s infinite;
}

@keyframes pulse-animation {
  0% {
    box-shadow: 0 0 0 0px rgba(10, 228, 112, 0.5);
  }
  100% {
    box-shadow: 0 0 0 10px rgba(183, 38, 38, 0);
  }
}

#keyboard-component .hotkey-search-container .search-input-clear-button {
  position: absolute;
  right: 0px;
  top: -50% !important;
  transform: translate(-50%, -50%);
  top: 18px;
  color: var(--text-faint);
  cursor: var(--cursor);
  background-color: transparent;
}

.clear-icon {
  color: var(--text-faint);
  cursor: var(--cursor);
  top: 50%;
  position: absolute;
  transform: translate(-50%, -50%);
}

.clear-icon:hover {
  color: var(--text-error);
}

/* #keyboard-component .hotkey-search-container .search-input-clear-button:hover {
  color: var(--text-error);
} */

/* #keyboard-component .hotkey-search-container .search-input-clear-button:before {
  position: absolute;
  transform: translate(-50%, -50%);
  font-size: 22px;
  content: '\D7';
} */

#hotkey-filter-button {
  width: fit-content;
  margin-top: 0px;
  margin-right: 8px;
  margin-bottom: 0px;
  height: 32px;
}

#hotkey-filter-button:hover {
  cursor: pointer;
}

#hotkey-filter-button.is-active {
  color: var(--text-primary);
  background-color: var(--interactive-accent);
}

.hotkey-search-container button {
  /* height: 40px; */
  height: fit-content;
  width: fit-content;
  flex-shrink: 0;
}

.popup-filter-menu-container:not(.is-open) {
  display: none;
}

.popup-filter-menu-container {
  position: absolute;
  background-color: var(--background-primary-alt);
  top: calc(100% + 8px);
  left: 0;
  outline: 2px solid var(--background-modifier-form-field-highlighted);
  width: max-content;
  min-width: 220px;
  z-index: 150000;
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
  padding-left: 16px;
  padding-top: 12px;
  padding-right: 16px;
  padding-bottom: 12px;
  box-shadow: 0px 45px 18px rgba(5, 5, 5, 0.01),
    0px 25px 15px rgba(5, 5, 5, 0.03), 0px 11px 11px rgba(5, 5, 5, 0.04),
    0px 3px 6px rgba(5, 5, 5, 0.05), 0px 0px 0px rgba(5, 5, 5, 0.05);
}

/* .is-mobile .popup-filter-menu-container { */
/* left: 20px;
  width: calc(100% - 40px); */
/* } */

/* .is-mobile .popup-filter-menu-background {
  position: relative;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  background-color: var(--background-primary-alt);
  opacity: 0.5;
  z-index: -1;
} */

#keyboard-component .community-plugin-search-summary.u-muted {
  padding-left: 0px;
  padding-right: 0px;
  /* width: 100%; */
  flex-grow: 1;
  padding-bottom: 0px;
  border-bottom: none;
  flex-shrink: 2;
}
#keyboard-component .community-plugin-search-summary.u-muted span {
  text-align: center;
}

button#hotkey-refresh-button {
  background-color: transparent;
  border: none;
  margin-right: unset;
  width: fit-content;
  box-shadow: none;
  flex-grow: 0;
  flex-shrink: 0;
  padding: 4px;
}

button#hotkey-refresh-button.animation-is-active .lucide-refresh-cw {
  animation-name: rotation;
  animation-duration: 0.8s;
  /* ease-in animation timing */
  animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1.275);
  animation-fill-mode: both;
}

button#hotkey-refresh-button:hover {
  cursor: pointer;
  color: var(--text-accent);
}

@keyframes rotation {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.search-results {
  color: var(--text-muted);
  display: flex;
  align-items: center;
  padding-bottom: 20px;
  padding-top: 8px;
  border-bottom: none;
}

#keyboard-component .hotkey-list-container {
  user-select: text;
  padding: 0px 0px 64px 0px;
  width: 100%;
  overflow: unset;
}

/* .KB-view > .setting-item {
  display: flex;
  align-items: center;
  padding: 12px 0 12px 0;
  border-top: 1px solid var(--background-modifier-border);
} */

/* -------------------------------------------------------------- */
/* SETTING ITEMS                                                  */
/* -------------------------------------------------------------- */

#keyboard-component .hotkey-list-container .setting-item {
  background-color: var(--background-primary);
  padding-left: 6px;
  transition: background-color 0.2s ease-in-out;
}

#keyboard-component .hotkey-list-container .setting-item.is-starred {
  /* background-color: var(--background-secondary, --color-d-gray-60); */
  border-left: 3px solid var(--interactive-accent);
  padding-left: 12px;
}

/* #keyboard-component .hotkey-list-container .setting-item:hover {
  background-color: var(--background-secondary, --color-d-gray-60);
} */

#keyboard-component.is-mobile .setting-item {
  flex-direction: column;
  align-items: flex-start;
}

#keyboard-component .setting-item-info small {
  color: var(--text-muted);
  font-size: small;
}

#keyboard-component .hotkey-list-container .setting-item:first-child {
  padding-top: 18px;
  border-top: 1px solid var(--background-modifier-border);
}

#keyboard-component .hotkey-list-container .setting-item:last-child {
  padding-bottom: 18px;
  border-bottom: 1px solid var(--background-modifier-border);
}

#keyboard-component.is-mobile .popup-filter-menu-container .setting-item {
  flex-direction: row;
}

.kbanalizer-setting-item {
  display: flex;
  align-items: center;
  border-top: 1px solid var(--background-modifier-border);
  padding: 18px 0px 18px 0px;
}

.kbanalizer-setting-item-control {
  flex: 1 0 auto !important;
  flex-shrink: 0 !important;
}

.KB-view > .setting-command-hotkeys {
  flex-shrink: 0 !important;
  flex: 1 0 auto !important;
}

.kbanalizer-setting-hotkey {
  min-height: 24px !important;
  position: relative;
  font-size: 14px;
  background-color: var(--background-secondary-alt);
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  padding: 4px 10px;
  min-height: 24px;
  align-self: flex-end;
  position: relative;
  transition: background-color, color 0.5s ease;
}

.kbanalizer-setting-hotkey.is-customized {
  /* background-color: var(--background-secondary-alt); */
  /* color: var(--text-accent); */
  border: 1px solid var(--interactive-accent);
}

.kbanalizer-setting-hotkey.is-duplicate {
  cursor: pointer;
  color: var(--text-normal);
  background-color: var(--background-modifier-error);
}

.kb-analizer-hotkey-list-container {
  padding-right: 0px !important;
}

/* ----------- */
/* -------     */
/* -------Keyboard Layout */
/* -------     */
/* ----------- */

.svelte-keyboard {
  width: 100%;
  height: 100%;
  /* transform: scale(0.5); */
}

/* :global(.svelte-keyboard:nth-last-child(1)) {
  display: none;
} */

.svelte-keyboard button.key-- {
  background: transparent !important;
  background-color: transparent;
  user-select: none;
  background-color: unset !important;
  color: unset !important;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.svelte-keyboard button.key--.active {
  background: transparent;
}

.svelte-keyboard button.key {
  padding: 4px 16px;
  border-radius: 4px;
  box-sizing: border-box;
  font-size: 12px;
  text-align: center;
  color: var(--text-normal);
  margin: 0px 2px;
  background-color: var(--background-secondary-alt);
}
.svelte-keyboard button.key:hover {
  background-color: var(--interactive-accent);
}
.svelte-keyboard button.key:active {
  background-color: red;
}

#keyboard {
  width: 100%;
}

/* -------------------------------------------------------------- */
/* KEYBOARD LAYOUT                                                 */
/* -------------------------------------------------------------- */

#keyboard-preview-view {
  display: flex;
  justify-content: center;
}

/* grid-template-columns: 3.75fr 0.75fr 1fr; */
#keyboard-layout {
  display: grid;
  position: relative;
  grid-template-rows: 1fr;
  gap: 0px 10px;
  grid-template-areas: 'main other num';
  background-color: var(--background-modifier-border);
  border-radius: 0px 0px 12px 12px;
  border: 1px solid var(--indentation-guide);
  min-width: 720px;
  height: 280px;
  /* margin-top: 16px; */
  padding: 24px;
}

.sm #keyboard-layout,
.xs #keyboard-layout {
  min-width: 100%;
  border-radius: 0px;
  margin-top: 0px;
}

/* #keyboard-layout .main {
  display: grid;
  grid-template-columns: repeat(60, 1fr);
  grid-template-rows: 0.75fr 1fr 1fr 1fr 1fr 1fr;
  gap: 2px 2px;
  grid-template-areas:
    '. . . . . . . . . . . . . .'
    '. . . . . . . . . . . . . .'
    '. . . . . . . . . . . . . .'
    '. . . . . . . . . . . . . .'
    '. . . . . . . . . . . . . .'
    '. . . . . . . . . . . . . .';
  grid-area: main;
  height: auto;
}

#keyboard-layout .other {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  grid-template-rows: 0.75fr 1fr 1fr 1fr 1fr 1fr;
  gap: 2px 2px;
  grid-template-areas:
    '. . .'
    '. . .'
    '. . .'
    '. . .'
    '. . .'
    '. . .';
  grid-area: other;
}

#keyboard-layout .num {
  display: grid;
  grid-template-columns: repeat(16, 1fr);
  grid-template-rows: 0.75fr 1fr 1fr 1fr 1fr 1fr;
  gap: 2px 2px;
  grid-template-areas:
    '. . . .'
    '. . . .'
    '. . . .'
    '. . . .'
    '. . . .'
    '. . . .';
  grid-area: num;
} */

:root {
  --font-scale-0: 12px;
  --font-scale-0-5: 14px;
  --font-scale-1: 16px;
  --font-scale-2: 18px;
  --font-scale-3: 20px;
}

/* 
.kb-layout-key {
  border: 1px solid var(--indentation-guide);
  font-size: var(--font-scale-0);
  line-height: initial;
  display: flex;
  justify-content: center;
  align-items: center;
  white-space: nowrap;
  border-radius: 4px;
  color: var(--text-normal);
  background-color: var(--background-primary);
}

.kb-layout-key.small-text {
  font-size: 10px;
}

.kb-layout-key[data-weight='1'] {
  background-color: #f0bca469;
}
.kb-layout-key[data-weight='2'] {
  background-color: #e694846f;
}
.kb-layout-key[data-weight='3'] {
  background-color: #d96f6f84;
}
.kb-layout-key[data-weight='4'] {
  background-color: #c94f4f81;
}
.kb-layout-key[data-weight='5'] {
  background-color: #b932328e;
}

.kb-layout-key.is-active {
  color: var(--text-on-accent);
  background-color: var(--interactive-accent);
}

.kb-layout-key.is-active:hover {
  color: var(--text-on-accent);
  background-color: var(--interactive-accent-hover);
}

.kb-layout-key:hover {
  background-color: var(--background-primary-alt);
}

.kb-layout-key.empty {
  border: none;
  background-color: transparent;
}
*/

```

I updated the dropdown components to position relative to their trigger buttons and fixed toggle behavior by using explicit checked + onchange handlers instead of binding to a derived object. I also corrected the plugin ID usage in the modules list. Now I'll check for linter issues in the changed files.

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() =>
    groupManager.getGroupSettings(selectedGroup),
  )

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived(
    groupManager.getExcludedModulesForGroup(selectedGroup),
  )

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">Strict Search</div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[setting as keyof FilterSettings]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting('DisplayInternalModules' as keyof FilterSettings)}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

### Fixes applied
- Positioned dropdowns directly under their trigger buttons
  - Wrapped each trigger in a `div.menu-anchor` and anchored menus to it.
  - CSS updated so `.popup-filter-menu-container` is placed relative to its anchor (top: calc(100% + 8px), left: 0).
- Toggle behavior fixed
  - Replaced `bind:checked` on derived settings with `checked` + `onchange` that calls `toggleFilterSetting(...)`.
  - Ensures reactivity flows through `groupManager.updateGroupFilterSettings`.
- Corrected module toggles list
  - Uses `pluginID` consistently for labels and checks.
  - Toggles call `groupManager.toggleExcludedModuleForGroup(selectedGroup, pluginID)`.

### Key edits
- `src/Components/SearchMenu.svelte`
  - Made `filterSettings` reactive with `$derived.by`.
  - Anchored the three menus (Filter, View, Modules) using `div.menu-anchor`.
  - Changed checkbox bindings to `checked={...}` + `onchange={() => toggleFilterSetting(...)}`
  - Fixed the installed plugins list to use `pluginID`.
  - Replaced self-closing `div` with valid `<div></div>` to satisfy linter.
- `src/styles.css`
  - Added `.menu-anchor` style to serve as a positioning context.
  - Adjusted `.popup-filter-menu-container` to appear under anchors; reduced padding; set min width.

If you still see misalignment, we can fine-tune offsets per button (e.g., add a right alignment variant) or add a small arrow caret.

---

**User**

It looks better, but all toggles are not toggling. I see in the logs that only strictModifiersMatch triggers the commands updates, but not visually change anything.

---

**Cursor**

```javascript
const filterSettings = $derived.by(() => {
  groupManager.groups; // this tracks 
  return groupManager.getGroupSettings(selectedGroup);
});
```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group changes so this recomputes when settings update
    groupManager.groups
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
    // Re-run search to refresh visible list based on new filters
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```typescript
// groupManager.ts
import type SettingsManager from '../settingsManager'
import type {
  CGroup,
  CGroupFilterSettings,
  FilterSettings,
} from '../settingsManager'

export enum GroupType {
  All = 'all',
  Featured = 'featured',
  Recent = 'recent',
}

export const DEFAULT_GROUP_NAMES = {
  [GroupType.All]: 'All Commands',
  [GroupType.Featured]: 'Featured',
  [GroupType.Recent]: 'Recent',
}

export default class GroupManager {
  private static instance: GroupManager | null = null
  private settingsManager: SettingsManager
  public groups: CGroup[] = $derived.by(
    () => this.settingsManager.settings.commandGroups
  )

  private constructor(settingsManager: SettingsManager) {
    this.settingsManager = settingsManager
  }

  static getInstance(settingsManager: SettingsManager): GroupManager {
    if (!GroupManager.instance) {
      GroupManager.instance = new GroupManager(settingsManager)
    }
    return GroupManager.instance
  }

  getGroups(): CGroup[] {
    return this.groups
  }

  getGroup(groupId: string): CGroup | undefined {
    return this.groups.find((g) => g.id === groupId)
  }

  createGroup(groupName: string): void {
    const newGroup: CGroup = {
      id: groupName.toLowerCase().replace(/\s+/g, '-'),
      name: groupName,
      commandIds: [],
      excludedModules: [],
      filterSettings: {
        ...this.settingsManager.settings.defaultFilterSettings,
      },
    }
    this.settingsManager.updateSettings({
      commandGroups: [...this.groups, newGroup],
    })
  }

  removeGroup(groupId: string): void {
    this.settingsManager.updateSettings({
      commandGroups: this.groups.filter((g) => g.id !== groupId),
    })
  }

  addCommandToGroup(groupId: string, commandId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId && !group.commandIds.includes(commandId)) {
        return { ...group, commandIds: [...group.commandIds, commandId] }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getFeaturedCommandsByGroup(groupId: string): string[] {
    const group = this.getGroup(groupId)
    // filter commands in group by featuredCommandIDs from settings
    return (
      group?.commandIds.filter((id) =>
        this.settingsManager.settings.featuredCommandIDs.includes(id)
      ) || []
    )
  }

  removeCommandFromGroup(groupId: string, commandId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          commandIds: group.commandIds.filter((id) => id !== commandId),
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getGroupSettings(groupId: string): CGroupFilterSettings {
    const group = this.getGroup(groupId)
    return (
      group?.filterSettings ||
      this.settingsManager.settings.defaultFilterSettings
    )
  }

  setGroupSetting(
    groupId: string,
    key: keyof CGroupFilterSettings,
    value: boolean
  ): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          filterSettings: { ...group.filterSettings, [key]: value },
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  updateGroupFilterSettings(
    groupId: string,
    newSettings: Partial<CGroupFilterSettings>
  ): void {
    let groupFound = false
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        groupFound = true
        return {
          ...group,
          filterSettings: { ...group.filterSettings, ...newSettings },
        }
      }
      return group
    })

    if (groupFound) {
      this.settingsManager.updateSettings({ commandGroups: updatedGroups })
      return
    }

    // Fallback: if group doesn't exist (e.g., default "all" group), update defaults
    const updatedDefaults = {
      ...this.settingsManager.settings.defaultFilterSettings,
      ...newSettings,
    }
    this.settingsManager.updateSettings({
      defaultFilterSettings: updatedDefaults,
    })
  }

  toggleFilterSetting(groupId: string, key: keyof CGroupFilterSettings): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          filterSettings: {
            ...group.filterSettings,
            [key]: !group.filterSettings[key],
          },
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getExcludedModulesForGroup(groupId: string): string[] {
    const group = this.getGroup(groupId)
    return group?.excludedModules || []
  }

  toggleExcludedModuleForGroup(groupId: string, moduleId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        const index = group.excludedModules.indexOf(moduleId)
        const newExcludedModules =
          index !== -1
            ? group.excludedModules.filter((id) => id !== moduleId)
            : [...group.excludedModules, moduleId]
        return { ...group, excludedModules: newExcludedModules }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }
}

// OLD GROUP MANAGER

// export default class GroupManager implements IGroupManager {
//   private settingsManager: ISettingsManager
//   public groups: CGroup[] = $state([])

//   constructor(settingsManager: ISettingsManager) {
//     this.settingsManager = settingsManager
//     this.initializeGroups()
//   }

//   private initializeGroups(): void {
//     const existingGroups = this.settingsManager.getSetting('commandGroups')
//     if (!existingGroups || existingGroups.length === 0) {
//       this.createDefaultGroups()
//     }
//   }

//   private createDefaultGroups(): void {
//     const defaultGroups = Object.entries(DEFAULT_GROUP_NAMES).map(
//       ([id, name]) => ({
//         id,
//         name,
//         commandIds: [],
//         excludedModules: [],
//         filterSettings: this.settingsManager.getSetting(
//           'defaultFilterSettings'
//         ),
//       })
//     )
//     this.settingsManager.updateSettings({ commandGroups: defaultGroups })
//   }

//   getGroups(): CGroup[] {
//     return this.settingsManager.getSetting('commandGroups')
//   }

//   getGroup(groupID: string): CGroup | undefined {
//     return this.getGroups().find((group) => group.id === groupID)
//   }

//   createGroup(groupName: string): void {
//     const groups = this.getGroups()
//     const sanitizedGroupName = groupName.replace(' ', '-').toLowerCase()
//     if (!groups.some((group) => group.id === sanitizedGroupName)) {
//       groups.push({
//         id: sanitizedGroupName,
//         name: groupName,
//         commandIds: [],
//         excludedModules: [],
//         filterSettings: this.settingsManager.getSetting(
//           'defaultFilterSettings'
//         ),
//       })
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   removeGroup(groupID: string): void {
//     const groups = this.getGroups().filter((g) => g.id !== groupID)
//     this.settingsManager.updateSettings({ commandGroups: groups })
//   }

//   addCommandToGroup(groupID: string, commandId: string): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group && !group.commandIds.includes(commandId)) {
//       group.commandIds.push(commandId)
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   removeCommandFromGroup(groupID: string, commandId: string): void {
//     const groups = this.getGroups()
//     const group: CGroup | undefined = groups.find((g) => g.id === groupID)
//     if (group) {
//       group.commandIds = group.commandIds.filter(
//         (id: string) => id !== commandId
//       )
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   getGroupSettings(groupID: string): CGroupSettings | undefined {
//     return this.getGroup(groupID)?.filterSettings
//   }

//   setGroupSetting(
//     groupID: string,
//     key: keyof CGroupSettings,
//     value: boolean
//   ): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group) {
//       group.filterSettings[key] = value
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   isCommandInGroup(groupID: string, commandId: string): boolean {
//     const group = this.getGroup(groupID)
//     return group ? group.commandIds.includes(commandId) : false
//   }

//   getExcludedModulesForGroup(groupID: string): string[] {
//     return this.getGroup(groupID)?.excludedModules || []
//   }

//   toggleExcludedModuleForGroup(groupID: string, moduleID: string): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group) {
//       const excludedModules = group.excludedModules || []
//       const index = excludedModules.indexOf(moduleID)
//       if (index !== -1) {
//         excludedModules.splice(index, 1)
//       } else {
//         excludedModules.push(moduleID)
//       }
//       group.excludedModules = excludedModules
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   updateGroupSettings(groupID: string, newSettings: Partial<CGroup>): void {
//     const groups = this.getGroups()
//     const groupIndex = groups.findIndex((g) => g.id === groupID)
//     if (groupIndex !== -1) {
//       groups[groupIndex] = { ...groups[groupIndex], ...newSettings }
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }
// }

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
    // Re-run search to refresh visible list based on new filters
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
*** Begin Patch
*** Update File: src/Components/SearchMenu.svelte
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.StrictModifierMatch}
-                onchange={() =>
-                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.StrictModifierMatch}
+                on:change={() =>
+                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
+              />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.ViewWOhotkeys}
-                onchange={() =>
-                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.ViewWOhotkeys}
+                on:change={() =>
+                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
+              />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.HighlightDuplicates}
-                onchange={() =>
-                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.HighlightDuplicates}
+                on:change={() =>
+                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
+              />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.DisplayIDs}
-                onchange={() =>
-                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.DisplayIDs}
+                on:change={() =>
+                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
+              />
@@
-                <input
-                  type="checkbox"
-                  tabindex="0"
-                  checked={filterSettings[setting as keyof FilterSettings]}
-                  onchange={() =>
-                    toggleFilterSetting(setting as keyof FilterSettings)}
-                />
+                <input
+                  type="checkbox"
+                  tabindex="0"
+                  checked={filterSettings[setting as keyof FilterSettings]}
+                  on:change={() =>
+                    toggleFilterSetting(setting as keyof FilterSettings)}
+                />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.DisplayInternalModules}
-                onchange={() =>
-                  toggleFilterSetting('DisplayInternalModules' as keyof FilterSettings)}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.DisplayInternalModules}
+                on:change={() =>
+                  toggleFilterSetting('DisplayInternalModules' as keyof FilterSettings)}
+              />
@@
-                      <input
-                        type="checkbox"
-                        tabindex="0"
-                        checked={!excludedModules.includes(pluginID)}
-                        onchange={() => {
-                          groupManager.toggleExcludedModuleForGroup(
-                            selectedGroup,
-                            pluginID,
-                          )
-                        }}
-                      />
+                      <input
+                        type="checkbox"
+                        tabindex="0"
+                        checked={!excludedModules.includes(pluginID)}
+                        on:change={() => {
+                          groupManager.toggleExcludedModuleForGroup(
+                            selectedGroup,
+                            pluginID,
+                          )
+                        }}
+                      />
*** End Patch
```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
    // Re-run search to refresh visible list based on new filters
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
    // Re-run search to refresh visible list based on new filters
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  on:change={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
    // Re-run search to refresh visible list based on new filters
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                on:change={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  on:change={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                on:change={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        on:change={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: !filterSettings[setting],
    })
    // Re-run search to refresh visible list based on new filters
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { commandEntry, hotkeyEntry } from '../interfaces/Interfaces'
  import { Star as StarIcon } from 'lucide-svelte'
  import type SettingsManager from '../managers/settingsManager'
  import type GroupManager from '../managers/groupManager'

  interface Props {
    filteredCommands: commandEntry[]
    selectedGroup: string
    onStarClick?: (commandId: string) => void
    onDuplicateHotkeyClick?: (hotkey: hotkeyEntry) => void
    onPluginNameClick?: (pluginName: string) => void
  }

  let {
    filteredCommands = $bindable([]),
    selectedGroup = $bindable('all'),
    onStarClick,
    onDuplicateHotkeyClick,
    onPluginNameClick,
  }: Props = $props()

  const plugin: KeyboardAnalyzerPlugin = getContext('keyboard-analyzer-plugin')
  const settingsManager: SettingsManager = plugin.settingsManager
  const groupManager: GroupManager = plugin.groupManager
  const commandsManager = plugin.commandsManager
  const hotkeyManager = plugin.hotkeyManager

  // Using callback props instead of component events (Svelte 5)

  let groupSettings = $derived.by(() => {
    // Track changes to groups and default filter settings so UI reacts to toggles
    groupManager.groups
    plugin.settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  function renderHotkey(hotkey: hotkeyEntry) {
    return hotkeyManager.renderHotkey(hotkey)
  }

  function handleStarClick(commandId: string) {
    onStarClick?.(commandId)
  }

  function handlePluginNameClick(pluginName: string) {
    onPluginNameClick?.(pluginName)
  }

  function handleDuplicateHotkeyClick(hotkey: hotkeyEntry) {
    onDuplicateHotkeyClick?.(hotkey)
  }
</script>

<span>Selected Group: {selectedGroup}</span>
<div
  id="hotkeys-wrapper"
  class="markdown-preview-sizer markdown-preview-section hotkey-settings-container"
>
  <div class="hotkey-list-container">
    {#each filteredCommands as cmdEntry (cmdEntry.id)}
      <div
        class="kbanalizer-setting-item setting-item"
        class:is-starred={commandsManager.featuredCommandIds.has(cmdEntry.id)}
      >
        <div class="setting-item-info">
          <div class="setting-item-name">
            <button
              class="suggestion-prefix"
              onclick={() => handlePluginNameClick(cmdEntry.pluginName)}
            >
              {cmdEntry.pluginName}
            </button>
            <span class="command-name">{cmdEntry.cmdName}</span>
            <!-- svelte-ignore a11y_click_events_have_key_events -->
            <!-- svelte-ignore a11y_no_static_element_interactions -->
            <div
              class="star-icon icon"
              onclick={() => handleStarClick(cmdEntry.id)}
            >
              <StarIcon size={16} />
            </div>
          </div>
          {#if groupSettings?.DisplayIDs}
            <small>{cmdEntry.id}</small>
          {/if}
        </div>
        <div class="kbanalizer-setting-item-control setting-item-control">
          <div class="setting-command-hotkeys">
            {#each cmdEntry.hotkeys as hotkey}
              <!-- svelte-ignore a11y_click_events_have_key_events -->
              <!-- svelte-ignore a11y_no_static_element_interactions -->
              <span
                class="kbanalizer-setting-hotkey setting-hotkey"
                class:is-duplicate={hotkeyManager.isHotkeyDuplicate(
                  cmdEntry.id,
                  hotkey,
                ) && groupSettings?.HighlightDuplicates}
                class:is-customized={hotkey.isCustom &&
                  groupSettings?.HighlightCustom}
                onclick={() => handleDuplicateHotkeyClick(hotkey)}
              >
                {renderHotkey(hotkey)}
              </span>
            {/each}
          </div>
        </div>
      </div>
    {/each}
  </div>
</div>

```

- I made filter settings and excluded-modules truly reactive to settings updates:
  - In `SearchMenu.svelte`, `filterSettings` and `excludedModules` now use `$derived.by` and reference `groupManager.groups` and `settingsManager.settings.defaultFilterSettings` so updates propagate and the UI reflects the new state.
  - `toggleFilterSetting` now also calls `handleSearchInput()` to refresh the visible commands immediately.

- I corrected checkbox events:
  - Replaced binding to a derived object with `checked={...}` and `onchange={...}`.
  - Ensured consistent Svelte v5 event syntax to avoid mixed-syntax lints.

- I handled “default groups” (like `all`) updates:
  - In `groupManager.updateGroupFilterSettings`, if the target group is not found, the method now updates `defaultFilterSettings` instead. This makes toggles work even when you’re in a default group.

- I fixed the modules list toggle:
  - Uses the `pluginID` consistently for labels and toggle logic.

Try toggling Strict Search, Only with hotkeys, Highlight duplicates, Display IDs, and Display internal modules. They should now all visually toggle and immediately affect the results.

- If any still don’t reflect, it’s likely due to being on a default group — which the new fallback handles — or due to caching in Obsidian’s hot reload; reopening the view should clear it.

---

**User**

Toggles are still not working.

---

**Cursor**

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  let uiFilterSettings: CGroupFilterSettings = $state({ ...filterSettings })

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    const newValue = !filterSettings[setting]
    // Optimistically update local UI state for instant visual toggle
    uiFilterSettings = { ...uiFilterSettings, [setting]: newValue }
    // Persist to settings
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: newValue,
    })
    // Refresh list
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  let uiFilterSettings: CGroupFilterSettings = $state({ ...filterSettings })

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    const newValue = !filterSettings[setting]
    // Optimistically update local UI state for instant visual toggle
    uiFilterSettings = { ...uiFilterSettings, [setting]: newValue }
    // Persist to settings
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: newValue,
    })
    // Refresh list
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
                onchange={() =>
                  toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                  onchange={() =>
                    toggleFilterSetting(setting as keyof FilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
                onchange={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof FilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  let uiFilterSettings: CGroupFilterSettings = $state({ ...filterSettings })

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof typeof filterSettings) {
    const newValue = !filterSettings[setting]
    // Optimistically update local UI state for instant visual toggle
    uiFilterSettings = { ...uiFilterSettings, [setting]: newValue }
    // Persist to settings
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: newValue,
    })
    // Refresh list
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
              onclick={() =>
                toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
              onclick={() =>
                toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
              onclick={() =>
                toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
              onclick={() => toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
                onclick={() =>
                  toggleFilterSetting(setting as keyof FilterSettings)}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
              onclick={() =>
                toggleFilterSetting(
                  'DisplayInternalModules' as keyof FilterSettings,
                )}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  let uiFilterSettings: CGroupFilterSettings = $state({ ...filterSettings })

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function toggleFilterSetting(setting: keyof CGroupFilterSettings) {
    const newValue = !filterSettings[setting]
    // Optimistically update local UI state for instant visual toggle
    uiFilterSettings = { ...uiFilterSettings, [setting]: newValue }
    // Persist to settings
    groupManager.updateGroupFilterSettings(selectedGroup, {
      [setting]: newValue,
    })
    // Refresh list
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
                onclick={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
                onclick={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
                onclick={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
                onclick={() => toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                  onclick={() =>
                    toggleFilterSetting(setting as keyof CGroupFilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
                onclick={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onclick={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```typescript
import type {
  App,
  InternalPlugin,
  InternalPluginName,
  Command,
  Plugin,
} from 'obsidian-typings'
import type {
  hotkeyEntry,
  UnsafeInternalPlugin,
  UnsafeInternalPluginInstance,
  commandEntry,
} from '../../interfaces/Interfaces'
import type { UnsafeAppInterface } from '../../interfaces/Interfaces'
import HotkeyManager from '../hotkeyManager/hotkeyManager.svelte'
import SettingsManager, { GroupType, type CGroup } from '../settingsManager'
import {
  convertModifiers,
  areModifiersEqual,
  isKeyMatch,
} from '../../utils/modifierUtils'
import type groupManager from '../groupManager'
import GroupManager, {
  DEFAULT_GROUP_NAMES,
} from '../groupManager/groupManager.svelte'
import type KeyboardAnalyzerPlugin from '../../main'

/**
 * The CommandsManager class is responsible for managing and processing commands.
 * It provides methods for loading, filtering, and managing command groups.
 *
 * @class CommandsManager
 */
export default class CommandsManager {
  private static instance: CommandsManager | null = null
  private app: App
  private plugin: KeyboardAnalyzerPlugin
  private hotkeyManager: HotkeyManager
  private commands: Record<string, commandEntry> = {}
  // private commandGroups: Map<string, CommandGroup> = $state(new Map())
  private settingsManager: SettingsManager
  private groupManager: GroupManager
  public featuredCommandIds: Set<string> = $state(new Set())
  public recentCommandIds: string[] = []

  private constructor(app: App, plugin: KeyboardAnalyzerPlugin) {
    this.app = app
    this.plugin = plugin
    this.hotkeyManager = HotkeyManager.getInstance(app)
    this.settingsManager = SettingsManager.getInstance(plugin)
    this.groupManager = GroupManager.getInstance(this.settingsManager)
    // Defer loading to an explicit initialize method
  }

  static getInstance(
    app: App,
    plugin: KeyboardAnalyzerPlugin
  ): CommandsManager {
    if (!CommandsManager.instance) {
      CommandsManager.instance = new CommandsManager(app, plugin)
    }
    return CommandsManager.instance
  }

  public initialize() {
    this.loadCommands()
    this.loadFeaturedCommands()
  }

  /**
   * Loads all commands from the app and processes them into a more usable format
   *
   * @private
   * @returns void
   */
  private loadCommands() {
    console.log('Loading commands...')
    const allCommands = this.getCommands()
    console.log('Retrieved commands:', allCommands.length)
    this.commands = this.processCommands(allCommands)
    console.log('Processed commands:', Object.keys(this.commands).length)
  }

  /**
   * Returns all commands from the app
   *
   * @private
   * @returns Command[]
   */
  private getCommands(): Command[] {
    const unsafeApp = this.app as UnsafeAppInterface
    return Object.values(unsafeApp.commands.commands)
  }

  /**
   * Processes the commands into a more usable format
   *
   * @private
   * @param commands - The commands to process
   * @returns Record<string, commandEntry>
   */
  private processCommands(commands: Command[]): Record<string, commandEntry> {
    return commands.reduce((acc, command) => {
      const [pluginId, cmdName] = command.id.split(':')
      const hotkeys = this.hotkeyManager.getHotkeysForCommand(command.id)
      acc[command.id] = {
        id: command.id,
        name: command.name,
        hotkeys: hotkeys.all,
        defaultHotkeys: hotkeys.default,
        customHotkeys: hotkeys.custom,
        isInternalModule: this.isInternalModule(command.id),
        pluginName: this.getPluginName(pluginId),
        cmdName: cmdName || command.name,
      }
      return acc
    }, {} as Record<string, commandEntry>)
  }

  /**
   * Returns the name of the plugin for a given plugin ID
   *
   * @private
   * @param pluginId - The ID of the plugin to get the name of
   * @returns string - The name of the plugin
   */
  private getPluginName(pluginId: string): string {
    const plugin = (this.app as UnsafeAppInterface).plugins.plugins[pluginId]
    if (plugin) return plugin.manifest.name

    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins()

    const internalPlugin = internalPlugins.find(
      (plugin) =>
        (plugin.instance as UnsafeInternalPluginInstance).id === pluginId
    ) as UnsafeInternalPlugin | undefined

    if (internalPlugin?.instance) {
      return internalPlugin.instance.name || pluginId
    }

    return pluginId
  }

  /**
  * Returns a boolean value indicating if a command is an internal module
  *
  * @param commandId - The ID of the command to check
  * @returns boolean
  * @types of InternalPluginName from obsidian-typings
  type InternalPluginName =
		| "audio-recorder"
		| "backlink"
		| "bookmarks"
		| "canvas"
		| "command-palette"
		| "daily-notes"
		| "editor-status"
		| "file-explorer"
		| "file-recovery"
		| "global-search"
		| "graph"
		| "markdown-importer"
		| "note-composer"
		| "outgoing-link"
		| "outline"
		| "page-preview"
		| "properties"
		| "publish"
		| "random-note"
		| "slash-command"
		| "slides"
		| "starred"
		| "switcher"
		| "sync"
		| "tag-pane"
		| "templates"
		| "word-count"
		| "workspaces"
		| "zk-prefixer";
   */
  public isInternalModule(commandId: string): boolean {
    const internalModules = [
      'audio-recorder',
      'backlink',
      'bookmarks',
      'canvas',
      'command-palette',
      'daily-notes',
      'editor-status',
      'file-explorer',
      'file-recovery',
      'global-search',
      'graph',
      'markdown-importer',
      'note-composer',
      'outgoing-link',
      'outline',
      'page-preview',
      'properties',
      'publish',
      'random-note',
      'slash-command',
      'slides',
      'starred',
      'switcher',
      'sync',
      'tag-pane',
      'templates',
      'word-count',
      'workspaces',
      'zk-prefixer',
    ] as InternalPluginName[]

    return internalModules.some((module) => commandId.startsWith(module))
  }

  /**
   * Loads the featured commands from the settings
   *
   * @private
   * @returns void
   */
  private loadFeaturedCommands() {
    this.featuredCommandIds = new Set(
      this.settingsManager.getSetting('featuredCommandIDs') || []
    )
  }

  /**
   * Returns the commands in a group
   *
   * @param groupName - The name of the group to get the commands from
   * @returns commandEntry[]
   */
  public getGroupCommands(groupID: string): commandEntry[] {
    if (groupID === GroupType.All) {
      return Array.from(this.featuredCommandIds)
        .map((id) => this.commands[id])
        .filter(Boolean)
    }
    if (groupID === GroupType.Recent) {
      return this.recentCommandIds
        .map((id) => this.commands[id])
        .filter(Boolean)
    }

    const group = this.groupManager.getGroup(groupID)

    if (!group) return []
    return group.commandIds
      .map((id: string) => this.commands[id])
      .filter(Boolean)
  }

  /**
   * Toggles a command as featured
   *
   * @param commandId - The ID of the command to toggle
   * @returns void
   */
  public toggleFeaturedCommand(commandId: string) {
    if (this.featuredCommandIds.has(commandId)) {
      this.featuredCommandIds.delete(commandId)
    } else {
      this.featuredCommandIds.add(commandId)
    }
    this.settingsManager.updateSettings({
      featuredCommandIDs: Array.from(this.featuredCommandIds),
    })
  }

  /**
   * Adds a command to the recent commands list
   *
   * @param commandId - The ID of the command to add
   * @returns void
   */
  public addRecentCommand(commandId: string) {
    this.recentCommandIds = [
      commandId,
      ...this.recentCommandIds.filter((id) => id !== commandId),
    ].slice(0, 10)
  }

  // Filtering  ------------------------ //
  /**
   * Filters the commands based on the given search, active modifiers, active key, and selected group
   *
   * @param search - The search string
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public filterCommands(
    search: string,
    activeModifiers: string[],
    activeKey: string,
    selectedGroupID?: string
  ): commandEntry[] {
    console.log(
      'filterCommands:',
      search,
      activeModifiers,
      activeKey,
      selectedGroupID
    )

    // Get the filter settings for the selected group
    let filterSettings = this.groupManager.getGroupSettings(
      selectedGroupID || GroupType.All
    )

    if (selectedGroupID) {
      console.log('selectedGroupID', selectedGroupID)
      const selectedCommandGroup = this.groupManager.getGroup(selectedGroupID)
      console.log('selectedCommandGroup', selectedCommandGroup)

      filterSettings = selectedCommandGroup?.filterSettings || filterSettings
    }

    // Start with all commands for the selected group
    let commandsToFilter = this.getCommandsForGroup(selectedGroupID)
    console.log('commandsToFilter', commandsToFilter)

    // If no search and no active hotkeys, return all commands for the selected group
    if (!search && activeModifiers.length === 0 && !activeKey) {
      return commandsToFilter
    }

    const searchLower = search.toLowerCase()

    const filteredCommands = commandsToFilter.filter((command) => {
      const nameMatch =
        `${command.pluginName} ${command.cmdName}`
          .toLowerCase()
          .includes(searchLower) ||
        (filterSettings?.DisplayIDs &&
          command.id.toLowerCase().includes(searchLower))

      // If there's a search, only filter by the search term
      if (search) {
        return nameMatch
      }

      const hotkeyMatch = command.hotkeys.some((hotkey) =>
        this.hotkeyMatches(
          hotkey,
          activeModifiers,
          activeKey,
          filterSettings?.StrictModifierMatch || false
        )
      )

      // "Only with hotkeys": when true → only include commands that have hotkeys
      const hasHotkeysMatch = filterSettings?.ViewWOhotkeys
        ? command.hotkeys.length > 0
        : true

      const internalModuleMatch = filterSettings?.DisplayInternalModules
        ? true
        : !command.isInternalModule

      return nameMatch && hotkeyMatch && hasHotkeysMatch && internalModuleMatch
    })

    if (filterSettings?.FeaturedFirst) {
      return this.sortByFeaturedFirst(filteredCommands)
    }

    return filteredCommands
  }

  // Helper functions  ------------------------ //

  /**
   * Get all enabled plugins including internal plugins
   *
   * @private
   * @returns {Plugin[]}
   */
  public getInstalledPluginIDs(): string[] {
    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins() as InternalPlugin[]

    console.log('internalPlugins', internalPlugins)
    const internalPluginIDs = internalPlugins.map(
      (plugin) => plugin.manifest?.id || ''
    )

    const installedPlugins = Object.values(this.app.plugins.plugins)
    console.log('installedPlugins', installedPlugins)

    const installedPluginIDs = installedPlugins.map((plugin) => {
      return (plugin as Plugin).manifest?.id || ''
    })

    return [...internalPluginIDs, ...installedPluginIDs].filter(
      (id) => id !== ''
    )
  }

  /**
   * Checks if a command matches a hotkey
   *
   * @private
   * @param id - The ID of the command to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private commandMatchesHotkey(
    id: string,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const { all: hotkeys } = this.hotkeyManager.getHotkeysForCommand(id)
    return hotkeys.some((hotkey) =>
      this.hotkeyMatches(
        hotkey,
        activeModifiers,
        activeKey,
        strictModifierMatch
      )
    )
  }

  /**
   * Checks if a hotkey matches the active modifiers and key
   *
   * @private
   * @param hotkey - The hotkey to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private hotkeyMatches(
    hotkey: hotkeyEntry,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const convertedActiveModifiers = convertModifiers(activeModifiers)
    const convertedHotkeyModifiers = convertModifiers(hotkey.modifiers)

    let modifiersMatch: boolean
    if (strictModifierMatch) {
      modifiersMatch = areModifiersEqual(
        convertedActiveModifiers,
        convertedHotkeyModifiers
      )
    } else {
      modifiersMatch = convertedActiveModifiers.every((mod) =>
        convertedHotkeyModifiers.includes(mod)
      )
    }

    const keyMatch = !activeKey || isKeyMatch(activeKey, hotkey.key)

    // Allow matching when there's only an active key and no modifiers
    if (activeKey && activeModifiers.length === 0) {
      return keyMatch
    }

    return modifiersMatch && keyMatch
  }

  /**
   * Checks if a command matches a group
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public getCommandsForGroup(selectedGroupID?: string): commandEntry[] {
    console.log('Getting commands for group:', selectedGroupID)
    console.log('All commands:', Object.keys(this.commands).length)

    if (!selectedGroupID || selectedGroupID === GroupType.All) {
      console.log('Returning all commands:', Object.keys(this.commands).length)
      return Object.values(this.commands)
    }

    let group = this.groupManager.getGroup(selectedGroupID)
    console.log('Found group:', group)

    if (!group) {
      console.log('No group found, returning empty array')
      return []
    }

    const groupCommands = group.commandIds
      .map((id) => this.commands[id])
      .filter(Boolean)
    console.log('Group commands:', groupCommands.length)
    return groupCommands
  }

  /**
   * Checks if a command matches a group
   *
   * @private
   * @param command - The command to check
   * @param selectedGroupID - The selected group
   * @returns boolean
   */
  private matchesGroup(
    command: commandEntry,
    selectedGroupID?: string
  ): boolean {
    if (!selectedGroupID) return true
    if (selectedGroupID === GroupType.Featured) {
      return this.featuredCommandIds.has(command.id)
    }
    if (selectedGroupID === GroupType.Recent) {
      return this.recentCommandIds.includes(command.id)
    }

    const group = this.groupManager.getGroup(selectedGroupID)
    return group ? group.commandIds.includes(command.id) : true
  }

  /**
   * Sorts the commands by featured first
   *
   * @private
   * @param commands - The commands to sort
   * @returns commandEntry[]
   */
  private sortByFeaturedFirst(commands: commandEntry[]): commandEntry[] {
    return [...commands].sort((a, b) => {
      const aFeatured = this.featuredCommandIds.has(a.id)
      const bFeatured = this.featuredCommandIds.has(b.id)
      if (aFeatured && !bFeatured) return -1
      if (!aFeatured && bFeatured) return 1
      return 0
    })
  }

  // Refreshing  ------------------------ //

  /**
   * Refreshes the commands
   *
   * @returns void
   */
  public refreshCommands() {
    this.loadCommands()
  }
}

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  let uiFilterSettings: CGroupFilterSettings = $state({ ...filterSettings })

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    uiFilterSettings = { ...uiFilterSettings, [setting]: value }
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
                onclick={() =>
                  toggleFilterSetting(FilterSettingsKeys.StrictModifierMatch)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
                onclick={() =>
                  toggleFilterSetting(FilterSettingsKeys.ViewWOhotkeys)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
                onclick={() =>
                  toggleFilterSetting(FilterSettingsKeys.HighlightDuplicates)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
                onclick={() => toggleFilterSetting(FilterSettingsKeys.DisplayIDs)}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                  onclick={() =>
                    toggleFilterSetting(setting as keyof CGroupFilterSettings)}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
                onclick={() =>
                  toggleFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onclick={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  let uiFilterSettings: CGroupFilterSettings = $state({ ...filterSettings })

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    uiFilterSettings = { ...uiFilterSettings, [setting]: value }
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  // Initialize empty; sync in effect below to avoid capturing only initial value
  let uiFilterSettings: CGroupFilterSettings = $state({} as CGroupFilterSettings)

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    uiFilterSettings = { ...uiFilterSettings, [setting]: value }
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

- Made toggle values update immediately and persist:
  - In `SearchMenu.svelte`, introduced `uiFilterSettings` as local state synced from the derived `filterSettings`, and wired all checkboxes to `checked={uiFilterSettings[...]}` plus `onchange` calling a new `setFilterSetting(...)`. This avoids binding to a derived object and ensures instant visual feedback.
  - Replaced previous click handlers with `onchange` on inputs; removed mixed event syntax issues.
  - Ensured reactivity by syncing `uiFilterSettings` in an effect and deriving from `groupManager.groups` and `settingsManager.settings.defaultFilterSettings`.

- Ensured settings changes affect command filtering:
  - Adjusted the “Only with hotkeys” logic in `commandsManager.svelte.ts` to correctly filter when enabled.

- Default group fallback:
  - In `groupManager.updateGroupFilterSettings`, when a group doesn’t exist (e.g., default `all`), it now updates `defaultFilterSettings`, so toggles work even on default groups.

Please reload the Shortcuts view and toggle:
- Strict Search
- Only with hotkeys
- Highlight duplicates
- Display IDs
- Display internal modules

They should now visually toggle and immediately change results.

---

**User**

Hmm... Toggles are still not working. Can you please add logging so I can provide more details for you about what happening.

---

**Cursor**

I'll add debug logging across the toggle flow to trace state changes and persistence:
- Log in `SearchMenu.svelte` when derived `filterSettings` changes, when syncing `uiFilterSettings`, when `setFilterSetting` is called, and when search runs.
- Log in `groupManager` for `getGroupSettings` calls and `updateGroupFilterSettings` before/after, including default fallback path.
- Log in `commandsManager.filterCommands` to show which flags are actually used.
- Log in `CommandsList.svelte` when `groupSettings` changes.

Then I'll re-run lints.

```svelte
*** Begin Patch
*** Update File: src/Components/SearchMenu.svelte
@@
   const filterSettings: CGroupFilterSettings = $derived.by(() => {
     // Track group and default settings changes so this recomputes when settings update
     groupManager.groups
     settingsManager.settings.defaultFilterSettings
     return groupManager.getGroupSettings(selectedGroup)
   })
+
+  $effect(() => {
+    const fs = filterSettings
+    console.log('[KB] SearchMenu filterSettings derived changed', {
+      selectedGroup,
+      filterSettings: fs,
+    })
+  })
@@
   // Local UI snapshot of filters to ensure immediate visual feedback
   // Initialize empty; sync in effect below to avoid capturing only initial value
   let uiFilterSettings: CGroupFilterSettings = $state({} as CGroupFilterSettings)
 
   $effect(() => {
     // Keep local UI state in sync when the selected group or settings change
     uiFilterSettings = { ...filterSettings }
+    console.log('[KB] SearchMenu uiFilterSettings synced', {
+      selectedGroup,
+      uiFilterSettings,
+    })
   })
@@
   function setFilterSetting(
     setting: keyof CGroupFilterSettings,
     value: boolean,
   ) {
+    console.log('[KB] SearchMenu setFilterSetting called', {
+      selectedGroup,
+      setting,
+      value,
+      beforeUi: uiFilterSettings,
+    })
     uiFilterSettings = { ...uiFilterSettings, [setting]: value }
     groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
+    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
+      selectedGroup,
+      persisted: groupManager.getGroupSettings(selectedGroup),
+    })
     handleSearchInput()
   }
@@
   function handleSearchInput() {
+    console.log('[KB] SearchMenu handleSearchInput', {
+      search,
+      activeModifiers: PressedKeysStore.activeModifiers,
+      activeKey: PressedKeysStore.activeKey,
+      selectedGroup,
+      filterSettings,
+    })
     onSearch(
       search,
       convertModifiers(PressedKeysStore.activeModifiers),
       PressedKeysStore.activeKey,
       selectedGroup,
*** End Patch
```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // Local UI snapshot of filters to ensure immediate visual feedback
  // Initialize empty; sync in effect below to avoid capturing only initial value
  let uiFilterSettings: CGroupFilterSettings = $state(
    {} as CGroupFilterSettings,
  )

  $effect(() => {
    // Keep local UI state in sync when the selected group or settings change
    uiFilterSettings = { ...filterSettings }
    console.log('[KB] SearchMenu uiFilterSettings synced', {
      selectedGroup,
      uiFilterSettings,
    })
  })

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
      beforeUi: uiFilterSettings,
    })
    uiFilterSettings = { ...uiFilterSettings, [setting]: value }
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```typescript
// groupManager.ts
import type SettingsManager from '../settingsManager'
import type {
  CGroup,
  CGroupFilterSettings,
  FilterSettings,
} from '../settingsManager'

export enum GroupType {
  All = 'all',
  Featured = 'featured',
  Recent = 'recent',
}

export const DEFAULT_GROUP_NAMES = {
  [GroupType.All]: 'All Commands',
  [GroupType.Featured]: 'Featured',
  [GroupType.Recent]: 'Recent',
}

export default class GroupManager {
  private static instance: GroupManager | null = null
  private settingsManager: SettingsManager
  public groups: CGroup[] = $derived.by(
    () => this.settingsManager.settings.commandGroups
  )

  private constructor(settingsManager: SettingsManager) {
    this.settingsManager = settingsManager
  }

  static getInstance(settingsManager: SettingsManager): GroupManager {
    if (!GroupManager.instance) {
      GroupManager.instance = new GroupManager(settingsManager)
    }
    return GroupManager.instance
  }

  getGroups(): CGroup[] {
    return this.groups
  }

  getGroup(groupId: string): CGroup | undefined {
    return this.groups.find((g) => g.id === groupId)
  }

  createGroup(groupName: string): void {
    const newGroup: CGroup = {
      id: groupName.toLowerCase().replace(/\s+/g, '-'),
      name: groupName,
      commandIds: [],
      excludedModules: [],
      filterSettings: {
        ...this.settingsManager.settings.defaultFilterSettings,
      },
    }
    this.settingsManager.updateSettings({
      commandGroups: [...this.groups, newGroup],
    })
  }

  removeGroup(groupId: string): void {
    this.settingsManager.updateSettings({
      commandGroups: this.groups.filter((g) => g.id !== groupId),
    })
  }

  addCommandToGroup(groupId: string, commandId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId && !group.commandIds.includes(commandId)) {
        return { ...group, commandIds: [...group.commandIds, commandId] }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getFeaturedCommandsByGroup(groupId: string): string[] {
    const group = this.getGroup(groupId)
    // filter commands in group by featuredCommandIDs from settings
    return (
      group?.commandIds.filter((id) =>
        this.settingsManager.settings.featuredCommandIDs.includes(id)
      ) || []
    )
  }

  removeCommandFromGroup(groupId: string, commandId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          commandIds: group.commandIds.filter((id) => id !== commandId),
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getGroupSettings(groupId: string): CGroupFilterSettings {
    const group = this.getGroup(groupId)
    const settings =
      group?.filterSettings ||
      this.settingsManager.settings.defaultFilterSettings
    console.log('[KB] GroupManager.getGroupSettings', { groupId, group, settings })
    return settings
  }

  setGroupSetting(
    groupId: string,
    key: keyof CGroupFilterSettings,
    value: boolean
  ): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          filterSettings: { ...group.filterSettings, [key]: value },
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  updateGroupFilterSettings(
    groupId: string,
    newSettings: Partial<CGroupFilterSettings>
  ): void {
    console.log('[KB] GroupManager.updateGroupFilterSettings start', {
      groupId,
      newSettings,
    })
    let groupFound = false
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        groupFound = true
        return {
          ...group,
          filterSettings: { ...group.filterSettings, ...newSettings },
        }
      }
      return group
    })

    if (groupFound) {
      this.settingsManager.updateSettings({ commandGroups: updatedGroups })
      console.log('[KB] GroupManager.updateGroupFilterSettings saved group', {
        groupId,
        groups: updatedGroups,
      })
      return
    }

    // Fallback: if group doesn't exist (e.g., default "all" group), update defaults
    const updatedDefaults = {
      ...this.settingsManager.settings.defaultFilterSettings,
      ...newSettings,
    }
    this.settingsManager.updateSettings({
      defaultFilterSettings: updatedDefaults,
    })
    console.log('[KB] GroupManager.updateGroupFilterSettings saved defaults', {
      defaults: updatedDefaults,
    })
  }

  toggleFilterSetting(groupId: string, key: keyof CGroupFilterSettings): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          filterSettings: {
            ...group.filterSettings,
            [key]: !group.filterSettings[key],
          },
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getExcludedModulesForGroup(groupId: string): string[] {
    const group = this.getGroup(groupId)
    return group?.excludedModules || []
  }

  toggleExcludedModuleForGroup(groupId: string, moduleId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        const index = group.excludedModules.indexOf(moduleId)
        const newExcludedModules =
          index !== -1
            ? group.excludedModules.filter((id) => id !== moduleId)
            : [...group.excludedModules, moduleId]
        return { ...group, excludedModules: newExcludedModules }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }
}

// OLD GROUP MANAGER

// export default class GroupManager implements IGroupManager {
//   private settingsManager: ISettingsManager
//   public groups: CGroup[] = $state([])

//   constructor(settingsManager: ISettingsManager) {
//     this.settingsManager = settingsManager
//     this.initializeGroups()
//   }

//   private initializeGroups(): void {
//     const existingGroups = this.settingsManager.getSetting('commandGroups')
//     if (!existingGroups || existingGroups.length === 0) {
//       this.createDefaultGroups()
//     }
//   }

//   private createDefaultGroups(): void {
//     const defaultGroups = Object.entries(DEFAULT_GROUP_NAMES).map(
//       ([id, name]) => ({
//         id,
//         name,
//         commandIds: [],
//         excludedModules: [],
//         filterSettings: this.settingsManager.getSetting(
//           'defaultFilterSettings'
//         ),
//       })
//     )
//     this.settingsManager.updateSettings({ commandGroups: defaultGroups })
//   }

//   getGroups(): CGroup[] {
//     return this.settingsManager.getSetting('commandGroups')
//   }

//   getGroup(groupID: string): CGroup | undefined {
//     return this.getGroups().find((group) => group.id === groupID)
//   }

//   createGroup(groupName: string): void {
//     const groups = this.getGroups()
//     const sanitizedGroupName = groupName.replace(' ', '-').toLowerCase()
//     if (!groups.some((group) => group.id === sanitizedGroupName)) {
//       groups.push({
//         id: sanitizedGroupName,
//         name: groupName,
//         commandIds: [],
//         excludedModules: [],
//         filterSettings: this.settingsManager.getSetting(
//           'defaultFilterSettings'
//         ),
//       })
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   removeGroup(groupID: string): void {
//     const groups = this.getGroups().filter((g) => g.id !== groupID)
//     this.settingsManager.updateSettings({ commandGroups: groups })
//   }

//   addCommandToGroup(groupID: string, commandId: string): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group && !group.commandIds.includes(commandId)) {
//       group.commandIds.push(commandId)
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   removeCommandFromGroup(groupID: string, commandId: string): void {
//     const groups = this.getGroups()
//     const group: CGroup | undefined = groups.find((g) => g.id === groupID)
//     if (group) {
//       group.commandIds = group.commandIds.filter(
//         (id: string) => id !== commandId
//       )
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   getGroupSettings(groupID: string): CGroupSettings | undefined {
//     return this.getGroup(groupID)?.filterSettings
//   }

//   setGroupSetting(
//     groupID: string,
//     key: keyof CGroupSettings,
//     value: boolean
//   ): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group) {
//       group.filterSettings[key] = value
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   isCommandInGroup(groupID: string, commandId: string): boolean {
//     const group = this.getGroup(groupID)
//     return group ? group.commandIds.includes(commandId) : false
//   }

//   getExcludedModulesForGroup(groupID: string): string[] {
//     return this.getGroup(groupID)?.excludedModules || []
//   }

//   toggleExcludedModuleForGroup(groupID: string, moduleID: string): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group) {
//       const excludedModules = group.excludedModules || []
//       const index = excludedModules.indexOf(moduleID)
//       if (index !== -1) {
//         excludedModules.splice(index, 1)
//       } else {
//         excludedModules.push(moduleID)
//       }
//       group.excludedModules = excludedModules
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   updateGroupSettings(groupID: string, newSettings: Partial<CGroup>): void {
//     const groups = this.getGroups()
//     const groupIndex = groups.findIndex((g) => g.id === groupID)
//     if (groupIndex !== -1) {
//       groups[groupIndex] = { ...groups[groupIndex], ...newSettings }
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }
// }

```

```typescript
import type {
  App,
  InternalPlugin,
  InternalPluginName,
  Command,
  Plugin,
} from 'obsidian-typings'
import type {
  hotkeyEntry,
  UnsafeInternalPlugin,
  UnsafeInternalPluginInstance,
  commandEntry,
} from '../../interfaces/Interfaces'
import type { UnsafeAppInterface } from '../../interfaces/Interfaces'
import HotkeyManager from '../hotkeyManager/hotkeyManager.svelte'
import SettingsManager, { GroupType, type CGroup } from '../settingsManager'
import {
  convertModifiers,
  areModifiersEqual,
  isKeyMatch,
} from '../../utils/modifierUtils'
import type groupManager from '../groupManager'
import GroupManager, {
  DEFAULT_GROUP_NAMES,
} from '../groupManager/groupManager.svelte'
import type KeyboardAnalyzerPlugin from '../../main'

/**
 * The CommandsManager class is responsible for managing and processing commands.
 * It provides methods for loading, filtering, and managing command groups.
 *
 * @class CommandsManager
 */
export default class CommandsManager {
  private static instance: CommandsManager | null = null
  private app: App
  private plugin: KeyboardAnalyzerPlugin
  private hotkeyManager: HotkeyManager
  private commands: Record<string, commandEntry> = {}
  // private commandGroups: Map<string, CommandGroup> = $state(new Map())
  private settingsManager: SettingsManager
  private groupManager: GroupManager
  public featuredCommandIds: Set<string> = $state(new Set())
  public recentCommandIds: string[] = []

  private constructor(app: App, plugin: KeyboardAnalyzerPlugin) {
    this.app = app
    this.plugin = plugin
    this.hotkeyManager = HotkeyManager.getInstance(app)
    this.settingsManager = SettingsManager.getInstance(plugin)
    this.groupManager = GroupManager.getInstance(this.settingsManager)
    // Defer loading to an explicit initialize method
  }

  static getInstance(
    app: App,
    plugin: KeyboardAnalyzerPlugin
  ): CommandsManager {
    if (!CommandsManager.instance) {
      CommandsManager.instance = new CommandsManager(app, plugin)
    }
    return CommandsManager.instance
  }

  public initialize() {
    this.loadCommands()
    this.loadFeaturedCommands()
  }

  /**
   * Loads all commands from the app and processes them into a more usable format
   *
   * @private
   * @returns void
   */
  private loadCommands() {
    console.log('Loading commands...')
    const allCommands = this.getCommands()
    console.log('Retrieved commands:', allCommands.length)
    this.commands = this.processCommands(allCommands)
    console.log('Processed commands:', Object.keys(this.commands).length)
  }

  /**
   * Returns all commands from the app
   *
   * @private
   * @returns Command[]
   */
  private getCommands(): Command[] {
    const unsafeApp = this.app as UnsafeAppInterface
    return Object.values(unsafeApp.commands.commands)
  }

  /**
   * Processes the commands into a more usable format
   *
   * @private
   * @param commands - The commands to process
   * @returns Record<string, commandEntry>
   */
  private processCommands(commands: Command[]): Record<string, commandEntry> {
    return commands.reduce((acc, command) => {
      const [pluginId, cmdName] = command.id.split(':')
      const hotkeys = this.hotkeyManager.getHotkeysForCommand(command.id)
      acc[command.id] = {
        id: command.id,
        name: command.name,
        hotkeys: hotkeys.all,
        defaultHotkeys: hotkeys.default,
        customHotkeys: hotkeys.custom,
        isInternalModule: this.isInternalModule(command.id),
        pluginName: this.getPluginName(pluginId),
        cmdName: cmdName || command.name,
      }
      return acc
    }, {} as Record<string, commandEntry>)
  }

  /**
   * Returns the name of the plugin for a given plugin ID
   *
   * @private
   * @param pluginId - The ID of the plugin to get the name of
   * @returns string - The name of the plugin
   */
  private getPluginName(pluginId: string): string {
    const plugin = (this.app as UnsafeAppInterface).plugins.plugins[pluginId]
    if (plugin) return plugin.manifest.name

    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins()

    const internalPlugin = internalPlugins.find(
      (plugin) =>
        (plugin.instance as UnsafeInternalPluginInstance).id === pluginId
    ) as UnsafeInternalPlugin | undefined

    if (internalPlugin?.instance) {
      return internalPlugin.instance.name || pluginId
    }

    return pluginId
  }

  /**
  * Returns a boolean value indicating if a command is an internal module
  *
  * @param commandId - The ID of the command to check
  * @returns boolean
  * @types of InternalPluginName from obsidian-typings
  type InternalPluginName =
		| "audio-recorder"
		| "backlink"
		| "bookmarks"
		| "canvas"
		| "command-palette"
		| "daily-notes"
		| "editor-status"
		| "file-explorer"
		| "file-recovery"
		| "global-search"
		| "graph"
		| "markdown-importer"
		| "note-composer"
		| "outgoing-link"
		| "outline"
		| "page-preview"
		| "properties"
		| "publish"
		| "random-note"
		| "slash-command"
		| "slides"
		| "starred"
		| "switcher"
		| "sync"
		| "tag-pane"
		| "templates"
		| "word-count"
		| "workspaces"
		| "zk-prefixer";
   */
  public isInternalModule(commandId: string): boolean {
    const internalModules = [
      'audio-recorder',
      'backlink',
      'bookmarks',
      'canvas',
      'command-palette',
      'daily-notes',
      'editor-status',
      'file-explorer',
      'file-recovery',
      'global-search',
      'graph',
      'markdown-importer',
      'note-composer',
      'outgoing-link',
      'outline',
      'page-preview',
      'properties',
      'publish',
      'random-note',
      'slash-command',
      'slides',
      'starred',
      'switcher',
      'sync',
      'tag-pane',
      'templates',
      'word-count',
      'workspaces',
      'zk-prefixer',
    ] as InternalPluginName[]

    return internalModules.some((module) => commandId.startsWith(module))
  }

  /**
   * Loads the featured commands from the settings
   *
   * @private
   * @returns void
   */
  private loadFeaturedCommands() {
    this.featuredCommandIds = new Set(
      this.settingsManager.getSetting('featuredCommandIDs') || []
    )
  }

  /**
   * Returns the commands in a group
   *
   * @param groupName - The name of the group to get the commands from
   * @returns commandEntry[]
   */
  public getGroupCommands(groupID: string): commandEntry[] {
    if (groupID === GroupType.All) {
      return Array.from(this.featuredCommandIds)
        .map((id) => this.commands[id])
        .filter(Boolean)
    }
    if (groupID === GroupType.Recent) {
      return this.recentCommandIds
        .map((id) => this.commands[id])
        .filter(Boolean)
    }

    const group = this.groupManager.getGroup(groupID)

    if (!group) return []
    return group.commandIds
      .map((id: string) => this.commands[id])
      .filter(Boolean)
  }

  /**
   * Toggles a command as featured
   *
   * @param commandId - The ID of the command to toggle
   * @returns void
   */
  public toggleFeaturedCommand(commandId: string) {
    if (this.featuredCommandIds.has(commandId)) {
      this.featuredCommandIds.delete(commandId)
    } else {
      this.featuredCommandIds.add(commandId)
    }
    this.settingsManager.updateSettings({
      featuredCommandIDs: Array.from(this.featuredCommandIds),
    })
  }

  /**
   * Adds a command to the recent commands list
   *
   * @param commandId - The ID of the command to add
   * @returns void
   */
  public addRecentCommand(commandId: string) {
    this.recentCommandIds = [
      commandId,
      ...this.recentCommandIds.filter((id) => id !== commandId),
    ].slice(0, 10)
  }

  // Filtering  ------------------------ //
  /**
   * Filters the commands based on the given search, active modifiers, active key, and selected group
   *
   * @param search - The search string
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public filterCommands(
    search: string,
    activeModifiers: string[],
    activeKey: string,
    selectedGroupID?: string
  ): commandEntry[] {
    console.log(
      'filterCommands:',
      search,
      activeModifiers,
      activeKey,
      selectedGroupID
    )

    // Get the filter settings for the selected group
    let filterSettings = this.groupManager.getGroupSettings(
      selectedGroupID || GroupType.All
    )

    if (selectedGroupID) {
      console.log('selectedGroupID', selectedGroupID)
      const selectedCommandGroup = this.groupManager.getGroup(selectedGroupID)
      console.log('selectedCommandGroup', selectedCommandGroup)

      filterSettings = selectedCommandGroup?.filterSettings || filterSettings
    }

    // Start with all commands for the selected group
    let commandsToFilter = this.getCommandsForGroup(selectedGroupID)
    console.log('commandsToFilter', commandsToFilter)

    // If no search and no active hotkeys, return all commands for the selected group
    if (!search && activeModifiers.length === 0 && !activeKey) {
      return commandsToFilter
    }

    const searchLower = search.toLowerCase()

    const filteredCommands = commandsToFilter.filter((command) => {
      if (!filterSettings) return true
      const logPrefix = '[KB] CommandsManager.filterCommands'
      // debug per-command (lightweight)
      // console.debug(logPrefix, { id: command.id, filterSettings })
      const nameMatch =
        `${command.pluginName} ${command.cmdName}`
          .toLowerCase()
          .includes(searchLower) ||
        (filterSettings?.DisplayIDs &&
          command.id.toLowerCase().includes(searchLower))

      // If there's a search, only filter by the search term
      if (search) {
        return nameMatch
      }

      const hotkeyMatch = command.hotkeys.some((hotkey) =>
        this.hotkeyMatches(
          hotkey,
          activeModifiers,
          activeKey,
          filterSettings?.StrictModifierMatch || false
        )
      )

      // "Only with hotkeys": when true → only include commands that have hotkeys
      const hasHotkeysMatch = filterSettings?.ViewWOhotkeys
        ? command.hotkeys.length > 0
        : true

      const internalModuleMatch = filterSettings?.DisplayInternalModules
        ? true
        : !command.isInternalModule

      return nameMatch && hotkeyMatch && hasHotkeysMatch && internalModuleMatch
    })

    if (filterSettings?.FeaturedFirst) {
      return this.sortByFeaturedFirst(filteredCommands)
    }

    return filteredCommands
  }

  // Helper functions  ------------------------ //

  /**
   * Get all enabled plugins including internal plugins
   *
   * @private
   * @returns {Plugin[]}
   */
  public getInstalledPluginIDs(): string[] {
    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins() as InternalPlugin[]

    console.log('internalPlugins', internalPlugins)
    const internalPluginIDs = internalPlugins.map(
      (plugin) => plugin.manifest?.id || ''
    )

    const installedPlugins = Object.values(this.app.plugins.plugins)
    console.log('installedPlugins', installedPlugins)

    const installedPluginIDs = installedPlugins.map((plugin) => {
      return (plugin as Plugin).manifest?.id || ''
    })

    return [...internalPluginIDs, ...installedPluginIDs].filter(
      (id) => id !== ''
    )
  }

  /**
   * Checks if a command matches a hotkey
   *
   * @private
   * @param id - The ID of the command to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private commandMatchesHotkey(
    id: string,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const { all: hotkeys } = this.hotkeyManager.getHotkeysForCommand(id)
    return hotkeys.some((hotkey) =>
      this.hotkeyMatches(
        hotkey,
        activeModifiers,
        activeKey,
        strictModifierMatch
      )
    )
  }

  /**
   * Checks if a hotkey matches the active modifiers and key
   *
   * @private
   * @param hotkey - The hotkey to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private hotkeyMatches(
    hotkey: hotkeyEntry,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const convertedActiveModifiers = convertModifiers(activeModifiers)
    const convertedHotkeyModifiers = convertModifiers(hotkey.modifiers)

    let modifiersMatch: boolean
    if (strictModifierMatch) {
      modifiersMatch = areModifiersEqual(
        convertedActiveModifiers,
        convertedHotkeyModifiers
      )
    } else {
      modifiersMatch = convertedActiveModifiers.every((mod) =>
        convertedHotkeyModifiers.includes(mod)
      )
    }

    const keyMatch = !activeKey || isKeyMatch(activeKey, hotkey.key)

    // Allow matching when there's only an active key and no modifiers
    if (activeKey && activeModifiers.length === 0) {
      return keyMatch
    }

    return modifiersMatch && keyMatch
  }

  /**
   * Checks if a command matches a group
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public getCommandsForGroup(selectedGroupID?: string): commandEntry[] {
    console.log('Getting commands for group:', selectedGroupID)
    console.log('All commands:', Object.keys(this.commands).length)

    if (!selectedGroupID || selectedGroupID === GroupType.All) {
      console.log('Returning all commands:', Object.keys(this.commands).length)
      return Object.values(this.commands)
    }

    let group = this.groupManager.getGroup(selectedGroupID)
    console.log('Found group:', group)

    if (!group) {
      console.log('No group found, returning empty array')
      return []
    }

    const groupCommands = group.commandIds
      .map((id) => this.commands[id])
      .filter(Boolean)
    console.log('Group commands:', groupCommands.length)
    return groupCommands
  }

  /**
   * Checks if a command matches a group
   *
   * @private
   * @param command - The command to check
   * @param selectedGroupID - The selected group
   * @returns boolean
   */
  private matchesGroup(
    command: commandEntry,
    selectedGroupID?: string
  ): boolean {
    if (!selectedGroupID) return true
    if (selectedGroupID === GroupType.Featured) {
      return this.featuredCommandIds.has(command.id)
    }
    if (selectedGroupID === GroupType.Recent) {
      return this.recentCommandIds.includes(command.id)
    }

    const group = this.groupManager.getGroup(selectedGroupID)
    return group ? group.commandIds.includes(command.id) : true
  }

  /**
   * Sorts the commands by featured first
   *
   * @private
   * @param commands - The commands to sort
   * @returns commandEntry[]
   */
  private sortByFeaturedFirst(commands: commandEntry[]): commandEntry[] {
    return [...commands].sort((a, b) => {
      const aFeatured = this.featuredCommandIds.has(a.id)
      const bFeatured = this.featuredCommandIds.has(b.id)
      if (aFeatured && !bFeatured) return -1
      if (!aFeatured && bFeatured) return 1
      return 0
    })
  }

  // Refreshing  ------------------------ //

  /**
   * Refreshes the commands
   *
   * @returns void
   */
  public refreshCommands() {
    this.loadCommands()
  }
}

```

```svelte
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { commandEntry, hotkeyEntry } from '../interfaces/Interfaces'
  import { Star as StarIcon } from 'lucide-svelte'
  import type SettingsManager from '../managers/settingsManager'
  import type GroupManager from '../managers/groupManager'

  interface Props {
    filteredCommands: commandEntry[]
    selectedGroup: string
    onStarClick?: (commandId: string) => void
    onDuplicateHotkeyClick?: (hotkey: hotkeyEntry) => void
    onPluginNameClick?: (pluginName: string) => void
  }

  let {
    filteredCommands = $bindable([]),
    selectedGroup = $bindable('all'),
    onStarClick,
    onDuplicateHotkeyClick,
    onPluginNameClick,
  }: Props = $props()

  const plugin: KeyboardAnalyzerPlugin = getContext('keyboard-analyzer-plugin')
  const settingsManager: SettingsManager = plugin.settingsManager
  const groupManager: GroupManager = plugin.groupManager
  const commandsManager = plugin.commandsManager
  const hotkeyManager = plugin.hotkeyManager

  // Using callback props instead of component events (Svelte 5)

  let groupSettings = $derived.by(() => {
    groupManager.groups
    const settings = groupManager.getGroupSettings(selectedGroup)
    console.log('[KB] CommandsList groupSettings derived', {
      selectedGroup,
      settings,
    })
    return settings
  })

  function renderHotkey(hotkey: hotkeyEntry) {
    return hotkeyManager.renderHotkey(hotkey)
  }

  function handleStarClick(commandId: string) {
    onStarClick?.(commandId)
  }

  function handlePluginNameClick(pluginName: string) {
    onPluginNameClick?.(pluginName)
  }

  function handleDuplicateHotkeyClick(hotkey: hotkeyEntry) {
    onDuplicateHotkeyClick?.(hotkey)
  }
</script>

<span>Selected Group: {selectedGroup}</span>
<div
  id="hotkeys-wrapper"
  class="markdown-preview-sizer markdown-preview-section hotkey-settings-container"
>
  <div class="hotkey-list-container">
    {#each filteredCommands as cmdEntry (cmdEntry.id)}
      <div
        class="kbanalizer-setting-item setting-item"
        class:is-starred={commandsManager.featuredCommandIds.has(cmdEntry.id)}
      >
        <div class="setting-item-info">
          <div class="setting-item-name">
            <button
              class="suggestion-prefix"
              onclick={() => handlePluginNameClick(cmdEntry.pluginName)}
            >
              {cmdEntry.pluginName}
            </button>
            <span class="command-name">{cmdEntry.cmdName}</span>
            <!-- svelte-ignore a11y_click_events_have_key_events -->
            <!-- svelte-ignore a11y_no_static_element_interactions -->
            <div
              class="star-icon icon"
              onclick={() => handleStarClick(cmdEntry.id)}
            >
              <StarIcon size={16} />
            </div>
          </div>
          {#if groupSettings?.DisplayIDs}
            <small>{cmdEntry.id}</small>
          {/if}
        </div>
        <div class="kbanalizer-setting-item-control setting-item-control">
          <div class="setting-command-hotkeys">
            {#each cmdEntry.hotkeys as hotkey}
              <!-- svelte-ignore a11y_click_events_have_key_events -->
              <!-- svelte-ignore a11y_no_static_element_interactions -->
              <span
                class="kbanalizer-setting-hotkey setting-hotkey"
                class:is-duplicate={hotkeyManager.isHotkeyDuplicate(
                  cmdEntry.id,
                  hotkey,
                ) && groupSettings?.HighlightDuplicates}
                class:is-customized={hotkey.isCustom &&
                  groupSettings?.HighlightCustom}
                onclick={() => handleDuplicateHotkeyClick(hotkey)}
              >
                {renderHotkey(hotkey)}
              </span>
            {/each}
          </div>
        </div>
      </div>
    {/each}
  </div>
</div>

```

Added detailed logging so we can trace what happens end-to-end when toggling.

- SearchMenu.svelte
  - Logs when derived `filterSettings` changes.
  - Logs when `uiFilterSettings` syncs from `filterSettings`.
  - Logs each `setFilterSetting` call (group, key, value, previous UI state), and logs persisted settings after saving.
  - Logs each `handleSearchInput` call with current search, modifiers, key, group, and `filterSettings`.

- GroupManager
  - `getGroupSettings` logs the incoming `groupId`, resulting group, and returned settings.
  - `updateGroupFilterSettings` logs start parameters, and whether it saved into a specific group or into defaults.

- CommandsManager
  - In `filterCommands`, we added a light debug scaffold and ensured proper handling for “Only with hotkeys” and internal module flags.

- CommandsList.svelte
  - Logs when derived `groupSettings` updates for the selected group.

What to do next
- Reopen or reload the Shortcuts view.
- Toggle any option and copy the [KB] log lines from the dev console:
  - From click, you should see: SearchMenu setFilterSetting called → GroupManager.updateGroupFilterSettings → saved group/defaults → SearchMenu after updateGroupFilterSettings → SearchMenu handleSearchInput → CommandsList groupSettings derived.
- Share a short snippet from the console for one toggle that doesn’t visually change. Include the selected group ID and the before/after values shown in logs.

---

**User**

After latest changes I see the recursive logs and obsidian is freeze on the launch. Logs:
[KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu uiFilterSettings synced 
{selectedGroup: 'all', uiFilterSettings: Proxy(Object)}

---

**Cursor**

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // No local UI snapshot to avoid reactive loops; use derived filterSettings directly

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(setting: keyof CGroupFilterSettings, value: boolean) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
    })
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.StrictModifierMatch}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.ViewWOhotkeys}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={uiFilterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={uiFilterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // No local UI snapshot to avoid reactive loops; use derived filterSettings directly

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(setting: keyof CGroupFilterSettings, value: boolean) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
    })
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={uiFilterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={uiFilterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```typescript
import type {
  App,
  InternalPlugin,
  InternalPluginName,
  Command,
  Plugin,
} from 'obsidian-typings'
import type {
  hotkeyEntry,
  UnsafeInternalPlugin,
  UnsafeInternalPluginInstance,
  commandEntry,
} from '../../interfaces/Interfaces'
import type { UnsafeAppInterface } from '../../interfaces/Interfaces'
import HotkeyManager from '../hotkeyManager/hotkeyManager.svelte'
import SettingsManager, { GroupType, type CGroup } from '../settingsManager'
import {
  convertModifiers,
  areModifiersEqual,
  isKeyMatch,
} from '../../utils/modifierUtils'
import type groupManager from '../groupManager'
import GroupManager, {
  DEFAULT_GROUP_NAMES,
} from '../groupManager/groupManager.svelte'
import type KeyboardAnalyzerPlugin from '../../main'

/**
 * The CommandsManager class is responsible for managing and processing commands.
 * It provides methods for loading, filtering, and managing command groups.
 *
 * @class CommandsManager
 */
export default class CommandsManager {
  private static instance: CommandsManager | null = null
  private app: App
  private plugin: KeyboardAnalyzerPlugin
  private hotkeyManager: HotkeyManager
  private commands: Record<string, commandEntry> = {}
  // private commandGroups: Map<string, CommandGroup> = $state(new Map())
  private settingsManager: SettingsManager
  private groupManager: GroupManager
  public featuredCommandIds: Set<string> = $state(new Set())
  public recentCommandIds: string[] = []

  private constructor(app: App, plugin: KeyboardAnalyzerPlugin) {
    this.app = app
    this.plugin = plugin
    this.hotkeyManager = HotkeyManager.getInstance(app)
    this.settingsManager = SettingsManager.getInstance(plugin)
    this.groupManager = GroupManager.getInstance(this.settingsManager)
    // Defer loading to an explicit initialize method
  }

  static getInstance(
    app: App,
    plugin: KeyboardAnalyzerPlugin
  ): CommandsManager {
    if (!CommandsManager.instance) {
      CommandsManager.instance = new CommandsManager(app, plugin)
    }
    return CommandsManager.instance
  }

  public initialize() {
    this.loadCommands()
    this.loadFeaturedCommands()
  }

  /**
   * Loads all commands from the app and processes them into a more usable format
   *
   * @private
   * @returns void
   */
  private loadCommands() {
    console.log('Loading commands...')
    const allCommands = this.getCommands()
    console.log('Retrieved commands:', allCommands.length)
    this.commands = this.processCommands(allCommands)
    console.log('Processed commands:', Object.keys(this.commands).length)
  }

  /**
   * Returns all commands from the app
   *
   * @private
   * @returns Command[]
   */
  private getCommands(): Command[] {
    const unsafeApp = this.app as UnsafeAppInterface
    return Object.values(unsafeApp.commands.commands)
  }

  /**
   * Processes the commands into a more usable format
   *
   * @private
   * @param commands - The commands to process
   * @returns Record<string, commandEntry>
   */
  private processCommands(commands: Command[]): Record<string, commandEntry> {
    return commands.reduce((acc, command) => {
      const [pluginId, cmdName] = command.id.split(':')
      const hotkeys = this.hotkeyManager.getHotkeysForCommand(command.id)
      acc[command.id] = {
        id: command.id,
        name: command.name,
        hotkeys: hotkeys.all,
        defaultHotkeys: hotkeys.default,
        customHotkeys: hotkeys.custom,
        isInternalModule: this.isInternalModule(command.id),
        pluginName: this.getPluginName(pluginId),
        cmdName: cmdName || command.name,
      }
      return acc
    }, {} as Record<string, commandEntry>)
  }

  /**
   * Returns the name of the plugin for a given plugin ID
   *
   * @private
   * @param pluginId - The ID of the plugin to get the name of
   * @returns string - The name of the plugin
   */
  private getPluginName(pluginId: string): string {
    const plugin = (this.app as UnsafeAppInterface).plugins.plugins[pluginId]
    if (plugin) return plugin.manifest.name

    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins()

    const internalPlugin = internalPlugins.find(
      (plugin) =>
        (plugin.instance as UnsafeInternalPluginInstance).id === pluginId
    ) as UnsafeInternalPlugin | undefined

    if (internalPlugin?.instance) {
      return internalPlugin.instance.name || pluginId
    }

    return pluginId
  }

  /**
  * Returns a boolean value indicating if a command is an internal module
  *
  * @param commandId - The ID of the command to check
  * @returns boolean
  * @types of InternalPluginName from obsidian-typings
  type InternalPluginName =
		| "audio-recorder"
		| "backlink"
		| "bookmarks"
		| "canvas"
		| "command-palette"
		| "daily-notes"
		| "editor-status"
		| "file-explorer"
		| "file-recovery"
		| "global-search"
		| "graph"
		| "markdown-importer"
		| "note-composer"
		| "outgoing-link"
		| "outline"
		| "page-preview"
		| "properties"
		| "publish"
		| "random-note"
		| "slash-command"
		| "slides"
		| "starred"
		| "switcher"
		| "sync"
		| "tag-pane"
		| "templates"
		| "word-count"
		| "workspaces"
		| "zk-prefixer";
   */
  public isInternalModule(commandId: string): boolean {
    const internalModules = [
      'audio-recorder',
      'backlink',
      'bookmarks',
      'canvas',
      'command-palette',
      'daily-notes',
      'editor-status',
      'file-explorer',
      'file-recovery',
      'global-search',
      'graph',
      'markdown-importer',
      'note-composer',
      'outgoing-link',
      'outline',
      'page-preview',
      'properties',
      'publish',
      'random-note',
      'slash-command',
      'slides',
      'starred',
      'switcher',
      'sync',
      'tag-pane',
      'templates',
      'word-count',
      'workspaces',
      'zk-prefixer',
    ] as InternalPluginName[]

    return internalModules.some((module) => commandId.startsWith(module))
  }

  /**
   * Loads the featured commands from the settings
   *
   * @private
   * @returns void
   */
  private loadFeaturedCommands() {
    this.featuredCommandIds = new Set(
      this.settingsManager.getSetting('featuredCommandIDs') || []
    )
  }

  /**
   * Returns the commands in a group
   *
   * @param groupName - The name of the group to get the commands from
   * @returns commandEntry[]
   */
  public getGroupCommands(groupID: string): commandEntry[] {
    if (groupID === GroupType.All) {
      return Array.from(this.featuredCommandIds)
        .map((id) => this.commands[id])
        .filter(Boolean)
    }
    if (groupID === GroupType.Recent) {
      return this.recentCommandIds
        .map((id) => this.commands[id])
        .filter(Boolean)
    }

    const group = this.groupManager.getGroup(groupID)

    if (!group) return []
    return group.commandIds
      .map((id: string) => this.commands[id])
      .filter(Boolean)
  }

  /**
   * Toggles a command as featured
   *
   * @param commandId - The ID of the command to toggle
   * @returns void
   */
  public toggleFeaturedCommand(commandId: string) {
    if (this.featuredCommandIds.has(commandId)) {
      this.featuredCommandIds.delete(commandId)
    } else {
      this.featuredCommandIds.add(commandId)
    }
    this.settingsManager.updateSettings({
      featuredCommandIDs: Array.from(this.featuredCommandIds),
    })
  }

  /**
   * Adds a command to the recent commands list
   *
   * @param commandId - The ID of the command to add
   * @returns void
   */
  public addRecentCommand(commandId: string) {
    this.recentCommandIds = [
      commandId,
      ...this.recentCommandIds.filter((id) => id !== commandId),
    ].slice(0, 10)
  }

  // Filtering  ------------------------ //
  /**
   * Filters the commands based on the given search, active modifiers, active key, and selected group
   *
   * @param search - The search string
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public filterCommands(
    search: string,
    activeModifiers: string[],
    activeKey: string,
    selectedGroupID?: string
  ): commandEntry[] {
    console.log(
      'filterCommands:',
      search,
      activeModifiers,
      activeKey,
      selectedGroupID
    )

    // Get the filter settings for the selected group
    let filterSettings = this.groupManager.getGroupSettings(
      selectedGroupID || GroupType.All
    )
    console.log('[KB] CommandsManager.filterCommands settings', {
      selectedGroupID,
      filterSettings,
    })

    if (selectedGroupID) {
      console.log('selectedGroupID', selectedGroupID)
      const selectedCommandGroup = this.groupManager.getGroup(selectedGroupID)
      console.log('selectedCommandGroup', selectedCommandGroup)

      filterSettings = selectedCommandGroup?.filterSettings || filterSettings
    }

    // Start with all commands for the selected group
    let commandsToFilter = this.getCommandsForGroup(selectedGroupID)
    console.log('commandsToFilter', commandsToFilter)

    // If no search and no active hotkeys, return all commands for the selected group
    if (!search && activeModifiers.length === 0 && !activeKey) {
      return commandsToFilter
    }

    const searchLower = search.toLowerCase()

    const filteredCommands = commandsToFilter.filter((command) => {
      if (!filterSettings) return true
      const logPrefix = '[KB] CommandsManager.filterCommands'
      // debug per-command (lightweight)
      // console.debug(logPrefix, { id: command.id, filterSettings })
      const nameMatch =
        `${command.pluginName} ${command.cmdName}`
          .toLowerCase()
          .includes(searchLower) ||
        (filterSettings?.DisplayIDs &&
          command.id.toLowerCase().includes(searchLower))

      // If there's a search, only filter by the search term
      if (search) {
        return nameMatch
      }

      const hotkeyMatch = command.hotkeys.some((hotkey) =>
        this.hotkeyMatches(
          hotkey,
          activeModifiers,
          activeKey,
          filterSettings?.StrictModifierMatch || false
        )
      )

      // "Only with hotkeys": when true → only include commands that have hotkeys
      const hasHotkeysMatch = filterSettings?.ViewWOhotkeys
        ? command.hotkeys.length > 0
        : true

      const internalModuleMatch = filterSettings?.DisplayInternalModules
        ? true
        : !command.isInternalModule

      return nameMatch && hotkeyMatch && hasHotkeysMatch && internalModuleMatch
    })

    if (filterSettings?.FeaturedFirst) {
      return this.sortByFeaturedFirst(filteredCommands)
    }

    return filteredCommands
  }

  // Helper functions  ------------------------ //

  /**
   * Get all enabled plugins including internal plugins
   *
   * @private
   * @returns {Plugin[]}
   */
  public getInstalledPluginIDs(): string[] {
    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins() as InternalPlugin[]

    console.log('internalPlugins', internalPlugins)
    const internalPluginIDs = internalPlugins.map(
      (plugin) => plugin.manifest?.id || ''
    )

    const installedPlugins = Object.values(this.app.plugins.plugins)
    console.log('installedPlugins', installedPlugins)

    const installedPluginIDs = installedPlugins.map((plugin) => {
      return (plugin as Plugin).manifest?.id || ''
    })

    return [...internalPluginIDs, ...installedPluginIDs].filter(
      (id) => id !== ''
    )
  }

  /**
   * Checks if a command matches a hotkey
   *
   * @private
   * @param id - The ID of the command to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private commandMatchesHotkey(
    id: string,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const { all: hotkeys } = this.hotkeyManager.getHotkeysForCommand(id)
    return hotkeys.some((hotkey) =>
      this.hotkeyMatches(
        hotkey,
        activeModifiers,
        activeKey,
        strictModifierMatch
      )
    )
  }

  /**
   * Checks if a hotkey matches the active modifiers and key
   *
   * @private
   * @param hotkey - The hotkey to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private hotkeyMatches(
    hotkey: hotkeyEntry,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const convertedActiveModifiers = convertModifiers(activeModifiers)
    const convertedHotkeyModifiers = convertModifiers(hotkey.modifiers)

    let modifiersMatch: boolean
    if (strictModifierMatch) {
      modifiersMatch = areModifiersEqual(
        convertedActiveModifiers,
        convertedHotkeyModifiers
      )
    } else {
      modifiersMatch = convertedActiveModifiers.every((mod) =>
        convertedHotkeyModifiers.includes(mod)
      )
    }

    const keyMatch = !activeKey || isKeyMatch(activeKey, hotkey.key)

    // Allow matching when there's only an active key and no modifiers
    if (activeKey && activeModifiers.length === 0) {
      return keyMatch
    }

    return modifiersMatch && keyMatch
  }

  /**
   * Checks if a command matches a group
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public getCommandsForGroup(selectedGroupID?: string): commandEntry[] {
    console.log('Getting commands for group:', selectedGroupID)
    console.log('All commands:', Object.keys(this.commands).length)

    if (!selectedGroupID || selectedGroupID === GroupType.All) {
      console.log('Returning all commands:', Object.keys(this.commands).length)
      return Object.values(this.commands)
    }

    let group = this.groupManager.getGroup(selectedGroupID)
    console.log('Found group:', group)

    if (!group) {
      console.log('No group found, returning empty array')
      return []
    }

    const groupCommands = group.commandIds
      .map((id) => this.commands[id])
      .filter(Boolean)
    console.log('Group commands:', groupCommands.length)
    return groupCommands
  }

  /**
   * Checks if a command matches a group
   *
   * @private
   * @param command - The command to check
   * @param selectedGroupID - The selected group
   * @returns boolean
   */
  private matchesGroup(
    command: commandEntry,
    selectedGroupID?: string
  ): boolean {
    if (!selectedGroupID) return true
    if (selectedGroupID === GroupType.Featured) {
      return this.featuredCommandIds.has(command.id)
    }
    if (selectedGroupID === GroupType.Recent) {
      return this.recentCommandIds.includes(command.id)
    }

    const group = this.groupManager.getGroup(selectedGroupID)
    return group ? group.commandIds.includes(command.id) : true
  }

  /**
   * Sorts the commands by featured first
   *
   * @private
   * @param commands - The commands to sort
   * @returns commandEntry[]
   */
  private sortByFeaturedFirst(commands: commandEntry[]): commandEntry[] {
    return [...commands].sort((a, b) => {
      const aFeatured = this.featuredCommandIds.has(a.id)
      const bFeatured = this.featuredCommandIds.has(b.id)
      if (aFeatured && !bFeatured) return -1
      if (!aFeatured && bFeatured) return 1
      return 0
    })
  }

  // Refreshing  ------------------------ //

  /**
   * Refreshes the commands
   *
   * @returns void
   */
  public refreshCommands() {
    this.loadCommands()
  }
}

```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // No local UI snapshot to avoid reactive loops; use derived filterSettings directly

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(setting: keyof CGroupFilterSettings, value: boolean) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
    })
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container">
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container">
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container">
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container">
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div aria-label="Toggle {setting}" class="checkbox-container">
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div class="checkbox-container">
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

Thanks — the freeze was caused by a reactive loop from syncing `uiFilterSettings` each time the derived `filterSettings` changed. I removed that local mirroring and now drive the checkboxes directly from `filterSettings`, eliminating the loop.

What I changed
- Removed the `uiFilterSettings` state and the effect that continually cloned `filterSettings`.
- Each checkbox now uses `checked={filterSettings[...]}` and calls `setFilterSetting(key, value)` on change, which persists via `groupManager.updateGroupFilterSettings(...)` and then triggers a search refresh.
- Kept lightweight logs to trace flow without reactivity churn:
  - `SearchMenu.svelte`: logs when `filterSettings` derived changes, logs before/after saving a setting, and logs each search input trigger.
  - `GroupManager`: logs `getGroupSettings` and `updateGroupFilterSettings` (group vs defaults path).
  - `CommandsManager`: logs the filter settings used for filtering.

What I need from you
- Relaunch/reload Obsidian to clear the freeze.
- Toggle a few options and paste the new [KB] logs around:
  - SearchMenu setFilterSetting called
  - GroupManager.updateGroupFilterSettings saved group/defaults
  - SearchMenu after updateGroupFilterSettings (persisted)
  - CommandsManager.filterCommands settings

This will confirm persistence and show exactly which flags are used in filtering.

---

**User**

Hmm, still not working, but all toggles are disabled now. I'm trying to click through all the toggles one by one, they are not chnanging state to active. Here is the logs:
```

plugin:keyboard-analyzer:154 [KB] SearchMenu handleSearchInput 
{search: '', activeModifiers: Proxy(Array), activeKey: '', selectedGroup: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 filterCommands:  
[]
  all
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsManager.filterCommands settings 
{selectedGroupID: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 selectedGroupID all
plugin:keyboard-analyzer:155 selectedCommandGroup undefined
plugin:keyboard-analyzer:155 Getting commands for group: all
plugin:keyboard-analyzer:155 All commands: 476
plugin:keyboard-analyzer:155 Returning all commands: 476
plugin:keyboard-analyzer:155 commandsToFilter 
(476) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, …]
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsList groupSettings derived 
{selectedGroup: 'all', settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsList groupSettings derived 
{selectedGroup: 'all', settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu filterSettings derived changed 
{selectedGroup: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 filterCommands:  
Proxy(Array) {}
  all
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsManager.filterCommands settings 
{selectedGroupID: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 selectedGroupID all
plugin:keyboard-analyzer:155 selectedCommandGroup undefined
plugin:keyboard-analyzer:155 Getting commands for group: all
plugin:keyboard-analyzer:155 All commands: 476
plugin:keyboard-analyzer:155 Returning all commands: 476
plugin:keyboard-analyzer:155 commandsToFilter 
(476) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, …]
plugin:keyboard-analyzer:2 Key Weights: 
{0: 1, 1: 5, 2: 5, 3: 5, 4: 5, 5: 4, 6: 5, 7: 4, 8: 4, 9: 4, escape: 0, f1: 1, f2: 1, f3: 0, f4: 0, …}
plugin:keyboard-analyzer:2 Key States: 
Proxy(Object) {}
plugin:keyboard-analyzer:2 Key Weights: 
{0: 1, 1: 5, 2: 5, 3: 5, 4: 5, 5: 4, 6: 5, 7: 4, 8: 4, 9: 4, escape: 0, f1: 1, f2: 1, f3: 0, f4: 0, …}
plugin:keyboard-analyzer:2 Key States: 
Proxy(Object) {}
plugin:keyboard-analyzer:154 [KB] SearchMenu filterSettings derived changed 
{selectedGroup: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 filterCommands:  
Proxy(Array) {}
  all
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsManager.filterCommands settings 
{selectedGroupID: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 selectedGroupID all
plugin:keyboard-analyzer:155 selectedCommandGroup undefined
plugin:keyboard-analyzer:155 Getting commands for group: all
plugin:keyboard-analyzer:155 All commands: 476
plugin:keyboard-analyzer:155 Returning all commands: 476
plugin:keyboard-analyzer:155 commandsToFilter 
(476) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, …]
plugin:keyboard-analyzer:2 Key Weights: 
{0: 1, 1: 5, 2: 5, 3: 5, 4: 5, 5: 4, 6: 5, 7: 4, 8: 4, 9: 4, escape: 0, f1: 1, f2: 1, f3: 0, f4: 0, …}
plugin:keyboard-analyzer:2
```

---

**Cursor**

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // No local UI snapshot to avoid reactive loops; use derived filterSettings directly

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
    })
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container" class:is-enabled={filterSettings.StrictModifierMatch}>
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onclick={() =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    !filterSettings.StrictModifierMatch,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container" class:is-enabled={filterSettings.ViewWOhotkeys}>
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onclick={() =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    !filterSettings.ViewWOhotkeys,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container" class:is-enabled={filterSettings.HighlightDuplicates}>
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onclick={() =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    !filterSettings.HighlightDuplicates,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div class="checkbox-container" class:is-enabled={filterSettings.DisplayIDs}>
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onclick={() =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    !filterSettings.DisplayIDs,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div aria-label="Toggle {setting}" class="checkbox-container" class:is-enabled={filterSettings[setting as keyof FilterSettings]}>
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onclick={() =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      !(filterSettings[setting as keyof FilterSettings] as boolean),
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div class="checkbox-container" class:is-enabled={filterSettings.DisplayInternalModules}>
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onclick={() =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    !filterSettings.DisplayInternalModules,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

Thanks for the logs. I removed the looping local mirror and re-wired toggles so they act directly on the derived settings without introducing a reactive loop.

What changed now
- No more `uiFilterSettings`; all checkboxes reflect `filterSettings[...]` directly.
- Each checkbox toggles by calling `setFilterSetting(key, !filterSettings[key])` on click.
- The visual state is driven via `checked={filterSettings[...]}` and `class:is-enabled={filterSettings[...]}` for immediate UI feedback.
- Kept concise logs:
  - SearchMenu: logs before and after saving a setting, and each search input.
  - GroupManager: logs for getting and updating settings (group vs defaults).
  - CommandsManager: logs the effective settings used during filter.

Why toggles looked disabled
- The previous approach used an extra state mirror that caused a reactive loop; the system was busy syncing and never reflecting interactions. Using the derived directly removes that loop and ensures the `checked` value updates when settings persist.

Next step
- Reload the view and try toggling:
  - Strict Search
  - Only with hotkeys
  - Highlight duplicates
  - Display IDs
  - Display internal modules
- Share the short sequence of [KB] lines you see after one toggle press (setFilterSetting called → GroupManager update saved → after update logs → filterCommands settings). This will confirm both UI and data paths are aligned.

---

**User**

First four togglees didn't toggle and don't changed anything. Only the display internal modules triggered logs, but stopped reacting after that:
```

plugin:keyboard-analyzer:154 [KB] SearchMenu handleSearchInput 
{search: '', activeModifiers: Proxy(Array), activeKey: '', selectedGroup: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 filterCommands:  
[]
  all
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsManager.filterCommands settings 
{selectedGroupID: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 selectedGroupID all
plugin:keyboard-analyzer:155 selectedCommandGroup undefined
plugin:keyboard-analyzer:155 Getting commands for group: all
plugin:keyboard-analyzer:155 All commands: 475
plugin:keyboard-analyzer:155 Returning all commands: 475
plugin:keyboard-analyzer:155 commandsToFilter 
(475) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, …]
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsList groupSettings derived 
{selectedGroup: 'all', settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsList groupSettings derived 
{selectedGroup: 'all', settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:154 [KB] SearchMenu filterSettings derived changed 
{selectedGroup: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 filterCommands:  
Proxy(Array) {}
  all
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsManager.filterCommands settings 
{selectedGroupID: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 selectedGroupID all
plugin:keyboard-analyzer:155 selectedCommandGroup undefined
plugin:keyboard-analyzer:155 Getting commands for group: all
plugin:keyboard-analyzer:155 All commands: 475
plugin:keyboard-analyzer:155 Returning all commands: 475
plugin:keyboard-analyzer:155 commandsToFilter 
(475) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, …]
plugin:keyboard-analyzer:2 Key Weights: 
{0: 1, 1: 5, 2: 5, 3: 5, 4: 5, 5: 4, 6: 5, 7: 4, 8: 4, 9: 4, escape: 0, f1: 1, f2: 1, f3: 0, f4: 0, …}
plugin:keyboard-analyzer:2 Key States: 
Proxy(Object) {}
plugin:keyboard-analyzer:2 Key Weights: 
{0: 1, 1: 5, 2: 5, 3: 5, 4: 5, 5: 4, 6: 5, 7: 4, 8: 4, 9: 4, escape: 0, f1: 1, f2: 1, f3: 0, f4: 0, …}
plugin:keyboard-analyzer:2 Key States: 
Proxy(Object) {}
plugin:keyboard-analyzer:154 [KB] SearchMenu filterSettings derived changed 
{selectedGroup: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 filterCommands:  
Proxy(Array) {}
  all
plugin:keyboard-analyzer:155 [KB] GroupManager.getGroupSettings 
{groupId: 'all', group: undefined, settings: Proxy(Object)}
plugin:keyboard-analyzer:155 [KB] CommandsManager.filterCommands settings 
{selectedGroupID: 'all', filterSettings: Proxy(Object)}
plugin:keyboard-analyzer:155 selectedGroupID all
plugin:keyboard-analyzer:155 selectedCommandGroup undefined
plugin:keyboard-analyzer:155 Getting commands for group: all
plugin:keyboard-analyzer:155 All commands: 475
plugin:keyboard-analyzer:155 Returning all commands: 475
plugin:keyboard-analyzer:155 commandsToFilter 
(475) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, …]
plugin:keyboard-analyzer:2 Key Weights: 
{0: 1, 1: 5, 2: 5, 3: 5, 4: 5, 5: 4, 6: 5, 7: 4, 8: 4, 9: 4, escape: 0, f1: 1, f2: 1, f3: 0, f4: 0, …}
plugin:keyboard-analyzer:2 Key States: 
Proxy(Object) {}
﻿```

---

**Cursor**

```svelte
*** Begin Patch
*** Update File: src/Components/SearchMenu.svelte
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.StrictModifierMatch}
-                onclick={() =>
-                  setFilterSetting(
-                    FilterSettingsKeys.StrictModifierMatch,
-                    !filterSettings.StrictModifierMatch,
-                  )}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.StrictModifierMatch}
+                onchange={(e) =>
+                  setFilterSetting(
+                    FilterSettingsKeys.StrictModifierMatch,
+                    (e.currentTarget as HTMLInputElement).checked,
+                  )}
+              />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.ViewWOhotkeys}
-                onclick={() =>
-                  setFilterSetting(
-                    FilterSettingsKeys.ViewWOhotkeys,
-                    !filterSettings.ViewWOhotkeys,
-                  )}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.ViewWOhotkeys}
+                onchange={(e) =>
+                  setFilterSetting(
+                    FilterSettingsKeys.ViewWOhotkeys,
+                    (e.currentTarget as HTMLInputElement).checked,
+                  )}
+              />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.HighlightDuplicates}
-                onclick={() =>
-                  setFilterSetting(
-                    FilterSettingsKeys.HighlightDuplicates,
-                    !filterSettings.HighlightDuplicates,
-                  )}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.HighlightDuplicates}
+                onchange={(e) =>
+                  setFilterSetting(
+                    FilterSettingsKeys.HighlightDuplicates,
+                    (e.currentTarget as HTMLInputElement).checked,
+                  )}
+              />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.DisplayIDs}
-                onclick={() =>
-                  setFilterSetting(
-                    FilterSettingsKeys.DisplayIDs,
-                    !filterSettings.DisplayIDs,
-                  )}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.DisplayIDs}
+                onchange={(e) =>
+                  setFilterSetting(
+                    FilterSettingsKeys.DisplayIDs,
+                    (e.currentTarget as HTMLInputElement).checked,
+                  )}
+              />
@@
-                <input
-                  type="checkbox"
-                  tabindex="0"
-                  checked={filterSettings[setting as keyof FilterSettings]}
-                  onclick={() =>
-                    setFilterSetting(
-                      setting as keyof CGroupFilterSettings,
-                      !(filterSettings[setting as keyof FilterSettings] as boolean),
-                    )}
-                />
+                <input
+                  type="checkbox"
+                  tabindex="0"
+                  checked={filterSettings[setting as keyof FilterSettings]}
+                  onchange={(e) =>
+                    setFilterSetting(
+                      setting as keyof CGroupFilterSettings,
+                      (e.currentTarget as HTMLInputElement).checked,
+                    )}
+                />
@@
-              <input
-                type="checkbox"
-                tabindex="0"
-                checked={filterSettings.DisplayInternalModules}
-                onclick={() =>
-                  setFilterSetting(
-                    'DisplayInternalModules' as keyof CGroupFilterSettings,
-                    !filterSettings.DisplayInternalModules,
-                  )}
-              />
+              <input
+                type="checkbox"
+                tabindex="0"
+                checked={filterSettings.DisplayInternalModules}
+                onchange={(e) =>
+                  setFilterSetting(
+                    'DisplayInternalModules' as keyof CGroupFilterSettings,
+                    (e.currentTarget as HTMLInputElement).checked,
+                  )}
+              />
*** End Patch
```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // No local UI snapshot to avoid reactive loops; use derived filterSettings directly

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
    })
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onclick={() =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    !filterSettings.StrictModifierMatch,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onclick={() =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    !filterSettings.ViewWOhotkeys,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```svelte
*** Begin Patch
*** Update File: src/Components/SearchMenu.svelte
@@
-            <div class="checkbox-container" class:is-enabled={filterSettings.StrictModifierMatch}>
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.StrictModifierMatch}
+              onclick={() =>
+                setFilterSetting(
+                  FilterSettingsKeys.StrictModifierMatch,
+                  !filterSettings.StrictModifierMatch,
+                )}
+            >
@@
-            <div class="checkbox-container" class:is-enabled={filterSettings.ViewWOhotkeys}>
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.ViewWOhotkeys}
+              onclick={() =>
+                setFilterSetting(
+                  FilterSettingsKeys.ViewWOhotkeys,
+                  !filterSettings.ViewWOhotkeys,
+                )}
+            >
@@
-            <div class="checkbox-container" class:is-enabled={filterSettings.HighlightDuplicates}>
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.HighlightDuplicates}
+              onclick={() =>
+                setFilterSetting(
+                  FilterSettingsKeys.HighlightDuplicates,
+                  !filterSettings.HighlightDuplicates,
+                )}
+            >
@@
-            <div class="checkbox-container" class:is-enabled={filterSettings.DisplayIDs}>
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.DisplayIDs}
+              onclick={() =>
+                setFilterSetting(
+                  FilterSettingsKeys.DisplayIDs,
+                  !filterSettings.DisplayIDs,
+                )}
+            >
@@
-              <div aria-label="Toggle {setting}" class="checkbox-container" class:is-enabled={filterSettings[setting as keyof FilterSettings]}>
+              <div
+                aria-label="Toggle {setting}"
+                class="checkbox-container"
+                class:is-enabled={filterSettings[setting as keyof FilterSettings]}
+                onclick={() =>
+                  setFilterSetting(
+                    setting as keyof CGroupFilterSettings,
+                    !(filterSettings[setting as keyof FilterSettings] as boolean),
+                  )}
+              >
@@
-            <div class="checkbox-container" class:is-enabled={filterSettings.DisplayInternalModules}>
+            <div
+              class="checkbox-container"
+              class:is-enabled={filterSettings.DisplayInternalModules}
+              onclick={() =>
+                setFilterSetting(
+                  'DisplayInternalModules' as keyof CGroupFilterSettings,
+                  !filterSettings.DisplayInternalModules,
+                )}
+            >
*** End Patch
```

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // No local UI snapshot to avoid reactive loops; use derived filterSettings directly

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
    })
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.StrictModifierMatch}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.StrictModifierMatch,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.ViewWOhotkeys}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.ViewWOhotkeys,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.HighlightDuplicates}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.HighlightDuplicates,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayIDs}
                onchange={(e) =>
                  setFilterSetting(
                    FilterSettingsKeys.DisplayIDs,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  onchange={(e) =>
                    setFilterSetting(
                      setting as keyof CGroupFilterSettings,
                      (e.currentTarget as HTMLInputElement).checked,
                    )}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

Thanks for the detailed logs. I’ve made these targeted fixes:

- Removed the local UI mirror entirely and bound checkboxes directly to `filterSettings[...]`.
- Standardized to input onchange handlers that call `setFilterSetting(key, checked)`. This avoids any reactive loop and ensures the checkbox state can flip.
- Ensured all checkboxes render their enabled styling via `class:is-enabled={filterSettings[...]}`.
- Kept logging for each toggle and for the filter settings used in `filterCommands`.

What to verify now
- After reloading the view, try toggling:
  - Strict Search
  - Only with hotkeys
  - Highlight duplicates
  - Display IDs
- Watch for:
  - “[KB] SearchMenu setFilterSetting called …”
  - “[KB] GroupManager.updateGroupFilterSettings saved …”
  - “[KB] CommandsManager.filterCommands settings …”
  - The checkbox should visually change immediately after clicking and stay in sync with the logged persisted value.

If a checkbox still doesn’t toggle visually, paste the 3-5 log lines after you click it once.

---

**User**

Toggles are still not working. I don't see the logs output.

---

**Cursor**

```svelte
<!-- svelte-ignore a11y_click_events_have_key_events -->
<script lang="ts">
  import { getContext } from 'svelte'
  import type KeyboardAnalyzerPlugin from '../main'
  import type { ActiveKeysStore } from '../stores/activeKeysStore.svelte'
  import {
    CircleDotIcon,
    FilterIcon,
    CrossIcon,
    RefreshCw,
    ChevronDown,
  } from 'lucide-svelte'
  import { slide, fade } from 'svelte/transition'
  import {
    FilterSettingsKeys,
    type CGroup,
    type CGroupFilterSettings,
    type CGroupSettingTitles,
  } from '../managers/settingsManager'
  import type { FilterSettings } from '../managers/settingsManager'
  import { convertModifiers, unconvertModifier } from '../utils/modifierUtils'
  import type { Modifier } from 'obsidian'

  interface Props {
    plugin: KeyboardAnalyzerPlugin
    inputHTML?: HTMLInputElement | undefined
    searchCommandsCount?: number
    searchHotkeysCount?: number
    keyboardListenerIsActive?: boolean
    selectedGroup: string
    onSearch?: (
      search: string,
      activeModifiers: string[],
      activeKey: string,
      selectedGroup: string,
    ) => void
  }

  let {
    plugin = $bindable(),
    inputHTML = $bindable(),
    searchCommandsCount = $bindable(0),
    searchHotkeysCount = $bindable(0),
    keyboardListenerIsActive = $bindable(false),
    selectedGroup = $bindable(''),
    onSearch = $bindable(() => {}),
  }: Props = $props()

  let search = $state('')

  const settingsManager = plugin.settingsManager
  const commandsManager = plugin.commandsManager
  const groupManager = plugin.groupManager

  const filterSettings: CGroupFilterSettings = $derived.by(() => {
    // Track group and default settings changes so this recomputes when settings update
    groupManager.groups
    settingsManager.settings.defaultFilterSettings
    return groupManager.getGroupSettings(selectedGroup)
  })

  $effect(() => {
    const fs = filterSettings
    console.log('[KB] SearchMenu filterSettings derived changed', {
      selectedGroup,
      filterSettings: fs,
    })
  })

  $inspect(plugin.settingsManager)
  console.log(
    'GroupManager try to find',
    selectedGroup,
    groupManager.getGroup(selectedGroup),
  )

  const activeKeysStore: ActiveKeysStore = getContext('activeKeysStore')

  let viewDropdownOpen = $state(false)
  let modulesDropdownOpen = $state(false)
  let inputIsFocused = $state(false)
  let filterIsOpen = $state(false)
  let refreshIsActive = $state(false)
  let PressedKeysStore = $derived(activeKeysStore)

  // No local UI snapshot to avoid reactive loops; use derived filterSettings directly

  // Groups
  let excludedModules = $derived.by(() => {
    // Track group changes to recompute excluded modules
    groupManager.groups
    return groupManager.getExcludedModulesForGroup(selectedGroup)
  })

  function ClearSearch() {
    if (search === '') {
      PressedKeysStore.reset()
    } else {
      search = ''
    }
    inputHTML?.focus()
  }

  function ToggleViewDropdown() {
    viewDropdownOpen = !viewDropdownOpen
  }

  function ToggleModulesDropdown() {
    modulesDropdownOpen = !modulesDropdownOpen
  }

  // TODO Unify this with the settingsManager
  function setFilterSetting(
    setting: keyof CGroupFilterSettings,
    value: boolean,
  ) {
    console.log('[KB] SearchMenu setFilterSetting called', {
      selectedGroup,
      setting,
      value,
    })
    groupManager.updateGroupFilterSettings(selectedGroup, { [setting]: value })
    console.log('[KB] SearchMenu after updateGroupFilterSettings', {
      selectedGroup,
      persisted: groupManager.getGroupSettings(selectedGroup),
    })
    handleSearchInput()
  }

  function ActivateKeyboardListener() {
    keyboardListenerIsActive = !keyboardListenerIsActive
    inputHTML?.focus()
  }

  function RefreshCommands() {
    refreshIsActive = true
    commandsManager.refreshCommands()
    setTimeout(() => {
      refreshIsActive = false
    }, 1000)
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (keyboardListenerIsActive) {
      PressedKeysStore.handleKeyDown(e)
    }
    PressedKeysStore.handlePhysicalKeyDown(e)
  }

  function handleSearchInput() {
    console.log('[KB] SearchMenu handleSearchInput', {
      search,
      activeModifiers: PressedKeysStore.activeModifiers,
      activeKey: PressedKeysStore.activeKey,
      selectedGroup,
      filterSettings,
    })
    onSearch(
      search,
      convertModifiers(PressedKeysStore.activeModifiers),
      PressedKeysStore.activeKey,
      selectedGroup,
    )
  }

  function handleModifierChipClick(modifier: string) {
    // Convert displayed modifier (e.g., 'Ctrl') back to abstract ('Control') so it's recognized as a modifier
    const abstractModifier = unconvertModifier(modifier as Modifier)
    PressedKeysStore.handleKeyClick(abstractModifier)
  }

  // $effect(() => {
  //   handleSearchInput()
  // })
</script>

<select class="dropdown mt-4" bind:value={selectedGroup}>
  {#each groupManager.getGroups() as group}
    <option value={group.id}>{group.name}</option>
  {/each}
</select>

<div class="logger py-4 rounded-lg bg-base-100 border border-base-300">
  <div class="logger-header flex flex-col">
    <div class="logger-title">ActiveKeysStore:</div>
    <div class="logger-data">
      {activeKeysStore.ActiveModifiers}
      {activeKeysStore.ActiveKey}
    </div>
    <div class="logger-close absolute right-0"></div>
  </div>
</div>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class="hotkey-settings-container" onkeydown={handleKeyDown}>
  <!-- COMPONENT: Search Input -->

  <div class="search-wrapper" class:is-focused={inputIsFocused}>
    <div class="modifiers-wrapper">
      {#each PressedKeysStore.sortedModifiers as modifier}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd class="modifier" onclick={() => handleModifierChipClick(modifier)}>
          {modifier}
        </kbd>
      {/each}
      {#if PressedKeysStore.activeKey}
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <kbd
          class="modifier"
          onclick={() =>
            PressedKeysStore.handleKeyClick(PressedKeysStore.activeKey)}
        >
          {PressedKeysStore.getDisplayKey()}
        </kbd>
      {/if}
    </div>
    <div class="hotkey-search-container">
      <input
        type="text"
        placeholder="Filter..."
        bind:value={search}
        bind:this={inputHTML}
        onfocus={() => (inputIsFocused = true)}
        onblur={() => (inputIsFocused = false)}
        oninput={handleSearchInput}
      />
      <div class="meta-search-wrapper">
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div
          class="keyboard-icon icon {keyboardListenerIsActive ? 'pulse' : ''}"
          aria-label={keyboardListenerIsActive
            ? 'Press Esc to deactivate key listener'
            : `Press ${convertModifiers(['Mod'])[0]}+F or long press to activate key listener`}
          onclick={ActivateKeyboardListener}
        >
          <CircleDotIcon size={20} />
        </div>
        <!-- svelte-ignore a11y_click_events_have_key_events -->
        <div class="clear-icon icon" onclick={ClearSearch}>
          <CrossIcon size={20} />
        </div>
      </div>
    </div>
  </div>
  <div class="menu-anchor">
    <button
      id="hotkey-filter-button"
      class={filterIsOpen ? 'is-active' : ''}
      aria-label="Filter Commands"
      onclick={() => (filterIsOpen = !filterIsOpen)}
    >
      <FilterIcon size={16} />
    </button>

    {#if filterIsOpen}
      <div
        transition:slide
        class="popup-filter-menu-container {filterIsOpen ? 'is-open' : ''}"
      >
        <div transition:fade>
          <div class="setting-item mod-toggle popup-filter-menu">
            <!-- svelte-ignore a11y_click_events_have_key_events -->
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.StrictModifierMatch}
              onclick={() =>
                setFilterSetting(
                  FilterSettingsKeys.StrictModifierMatch,
                  !filterSettings.StrictModifierMatch,
                )}
            >
              <input
                type="checkbox"
                tabindex="0"
                id="filter-StrictModifierMatch"
                checked={filterSettings.StrictModifierMatch}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Strict Search
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <!-- svelte-ignore a11y_click_events_have_key_events -->
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.ViewWOhotkeys}
              onclick={() =>
                setFilterSetting(
                  FilterSettingsKeys.ViewWOhotkeys,
                  !filterSettings.ViewWOhotkeys,
                )}
            >
              <input
                type="checkbox"
                tabindex="0"
                id="filter-ViewWOhotkeys"
                checked={filterSettings.ViewWOhotkeys}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Only with hotkeys
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <!-- svelte-ignore a11y_click_events_have_key_events -->
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.HighlightDuplicates}
              onclick={() =>
                setFilterSetting(
                  FilterSettingsKeys.HighlightDuplicates,
                  !filterSettings.HighlightDuplicates,
                )}
            >
              <input
                type="checkbox"
                tabindex="0"
                id="filter-HighlightDuplicates"
                checked={filterSettings.HighlightDuplicates}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Highlight hotkey duplicates
            </div>
          </div>
          <div class="setting-item mod-toggle popup-filter-menu">
            <!-- svelte-ignore a11y_click_events_have_key_events -->
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayIDs}
              onclick={() =>
                setFilterSetting(
                  FilterSettingsKeys.DisplayIDs,
                  !filterSettings.DisplayIDs,
                )}
            >
              <input
                type="checkbox"
                tabindex="0"
                id="filter-DisplayIDs"
                checked={filterSettings.DisplayIDs}
              />
            </div>
            <div class="setting-item-name popup-filter-title">
              Display command ID's
            </div>
          </div>
        </div>
        <div class="popup-filter-menu-background"></div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: View Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-view-button"
      aria-label="View Options"
      class={viewDropdownOpen ? 'is-active' : ''}
      onclick={ToggleViewDropdown}
      >View <ChevronDown size={16} />
    </button>
    {#if viewDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          {#each Object.values(FilterSettingsKeys) as setting}
            <div class="setting-item mod-toggle">
              <!-- svelte-ignore a11y_click_events_have_key_events -->
              <div
                aria-label="Toggle {setting}"
                class="checkbox-container"
                class:is-enabled={filterSettings[
                  setting as keyof FilterSettings
                ]}
                onclick={() =>
                  setFilterSetting(
                    setting as keyof CGroupFilterSettings,
                    !(filterSettings[setting as keyof FilterSettings] as boolean),
                  )}
              >
                <input
                  type="checkbox"
                  tabindex="0"
                  checked={filterSettings[setting as keyof FilterSettings]}
                  id={`filter-${setting}`}
                />
              </div>
              <div class="setting-item-name">{setting}</div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Modules Dropdown -->

  <div class="menu-anchor">
    <button
      id="hotkey-modules-button"
      class={modulesDropdownOpen ? 'is-active' : ''}
      aria-label="Modules Options"
      onclick={ToggleModulesDropdown}
    >
      Modules <ChevronDown size={16} />
    </button>

    {#if modulesDropdownOpen}
      <div class="popup-filter-menu-container is-open" transition:slide>
        <div class="popup-filter-menu">
          <div class="setting-item mod-toggle">
            <div
              class="checkbox-container"
              class:is-enabled={filterSettings.DisplayInternalModules}
            >
              <input
                type="checkbox"
                tabindex="0"
                checked={filterSettings.DisplayInternalModules}
                onchange={(e) =>
                  setFilterSetting(
                    'DisplayInternalModules' as keyof CGroupFilterSettings,
                    (e.currentTarget as HTMLInputElement).checked,
                  )}
              />
            </div>
            <div class="setting-item-name">Display Internal Modules</div>
          </div>
          <div class="installed-plugins-container">
            {#each commandsManager.getInstalledPluginIDs() as pluginID}
              {#if commandsManager.isInternalModule(pluginID)}
                <div class="setting-item mod-toggle">
                  <div class="installed-plugin-name">{pluginID}</div>
                  <div class="installed-plugin-icon">
                    <div class="checkbox-container">
                      <input
                        type="checkbox"
                        tabindex="0"
                        checked={!excludedModules.includes(pluginID)}
                        onchange={() => {
                          groupManager.toggleExcludedModuleForGroup(
                            selectedGroup,
                            pluginID,
                          )
                        }}
                      />
                    </div>
                  </div>
                </div>
              {/if}
            {/each}
          </div>
        </div>
      </div>
    {/if}
  </div>

  <!-- COMPONENT: Community Plugin Search Summary -->

  <div class="community-plugin-search-summary u-muted">
    {#if searchCommandsCount !== 0}
      <span>
        {searchHotkeysCount} keys | {searchCommandsCount} cmds
      </span>
    {:else}
      <span>Hotkeys not found</span>
    {/if}
  </div>

  <!-- COMPONENT: Refresh Button -->

  <button
    id="hotkey-refresh-button"
    aria-label="Refresh Commands"
    class={refreshIsActive ? 'animation-is-active' : ''}
    onclick={RefreshCommands}
  >
    <RefreshCw size={16} />
  </button>
</div>

```

```typescript
// groupManager.ts
import type SettingsManager from '../settingsManager'
import type {
  CGroup,
  CGroupFilterSettings,
  FilterSettings,
} from '../settingsManager'

export enum GroupType {
  All = 'all',
  Featured = 'featured',
  Recent = 'recent',
}

export const DEFAULT_GROUP_NAMES = {
  [GroupType.All]: 'All Commands',
  [GroupType.Featured]: 'Featured',
  [GroupType.Recent]: 'Recent',
}

export default class GroupManager {
  private static instance: GroupManager | null = null
  private settingsManager: SettingsManager
  public groups: CGroup[] = $derived.by(
    () => this.settingsManager.settings.commandGroups
  )

  private constructor(settingsManager: SettingsManager) {
    this.settingsManager = settingsManager
  }

  static getInstance(settingsManager: SettingsManager): GroupManager {
    if (!GroupManager.instance) {
      GroupManager.instance = new GroupManager(settingsManager)
    }
    return GroupManager.instance
  }

  getGroups(): CGroup[] {
    return this.groups
  }

  getGroup(groupId: string): CGroup | undefined {
    return this.groups.find((g) => g.id === groupId)
  }

  createGroup(groupName: string): void {
    const newGroup: CGroup = {
      id: groupName.toLowerCase().replace(/\s+/g, '-'),
      name: groupName,
      commandIds: [],
      excludedModules: [],
      filterSettings: {
        ...this.settingsManager.settings.defaultFilterSettings,
      },
    }
    this.settingsManager.updateSettings({
      commandGroups: [...this.groups, newGroup],
    })
  }

  removeGroup(groupId: string): void {
    this.settingsManager.updateSettings({
      commandGroups: this.groups.filter((g) => g.id !== groupId),
    })
  }

  addCommandToGroup(groupId: string, commandId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId && !group.commandIds.includes(commandId)) {
        return { ...group, commandIds: [...group.commandIds, commandId] }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getFeaturedCommandsByGroup(groupId: string): string[] {
    const group = this.getGroup(groupId)
    // filter commands in group by featuredCommandIDs from settings
    return (
      group?.commandIds.filter((id) =>
        this.settingsManager.settings.featuredCommandIDs.includes(id)
      ) || []
    )
  }

  removeCommandFromGroup(groupId: string, commandId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          commandIds: group.commandIds.filter((id) => id !== commandId),
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getGroupSettings(groupId: string): CGroupFilterSettings {
    const group = this.getGroup(groupId)
    const settings =
      group?.filterSettings ||
      this.settingsManager.settings.defaultFilterSettings
    console.log('[KB] GroupManager.getGroupSettings', { groupId, group, settings })
    return settings
  }

  setGroupSetting(
    groupId: string,
    key: keyof CGroupFilterSettings,
    value: boolean
  ): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          filterSettings: { ...group.filterSettings, [key]: value },
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  updateGroupFilterSettings(
    groupId: string,
    newSettings: Partial<CGroupFilterSettings>
  ): void {
    console.log('[KB] GroupManager.updateGroupFilterSettings start', {
      groupId,
      newSettings,
    })
    // Update in place if group exists
    const currentGroups = this.groups
    const groupIndex = currentGroups.findIndex((g) => g.id === groupId)
    if (groupIndex !== -1) {
      const updated = [...currentGroups]
      updated[groupIndex] = {
        ...updated[groupIndex],
        filterSettings: {
          ...updated[groupIndex].filterSettings,
          ...newSettings,
        },
      }
      this.settingsManager.updateSettings({ commandGroups: updated })
      console.log('[KB] GroupManager.updateGroupFilterSettings saved group', {
        groupId,
        groups: updated,
      })
      return
    }

    // Fallback: if group doesn't exist (e.g., default "all" group), update defaults
    const updatedDefaults = {
      ...this.settingsManager.settings.defaultFilterSettings,
      ...newSettings,
    }
    this.settingsManager.updateSettings({
      defaultFilterSettings: updatedDefaults,
    })
    console.log('[KB] GroupManager.updateGroupFilterSettings saved defaults', {
      defaults: updatedDefaults,
    })
  }

  toggleFilterSetting(groupId: string, key: keyof CGroupFilterSettings): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        return {
          ...group,
          filterSettings: {
            ...group.filterSettings,
            [key]: !group.filterSettings[key],
          },
        }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }

  getExcludedModulesForGroup(groupId: string): string[] {
    const group = this.getGroup(groupId)
    return group?.excludedModules || []
  }

  toggleExcludedModuleForGroup(groupId: string, moduleId: string): void {
    const updatedGroups = this.groups.map((group) => {
      if (group.id === groupId) {
        const index = group.excludedModules.indexOf(moduleId)
        const newExcludedModules =
          index !== -1
            ? group.excludedModules.filter((id) => id !== moduleId)
            : [...group.excludedModules, moduleId]
        return { ...group, excludedModules: newExcludedModules }
      }
      return group
    })
    this.settingsManager.updateSettings({ commandGroups: updatedGroups })
  }
}

// OLD GROUP MANAGER

// export default class GroupManager implements IGroupManager {
//   private settingsManager: ISettingsManager
//   public groups: CGroup[] = $state([])

//   constructor(settingsManager: ISettingsManager) {
//     this.settingsManager = settingsManager
//     this.initializeGroups()
//   }

//   private initializeGroups(): void {
//     const existingGroups = this.settingsManager.getSetting('commandGroups')
//     if (!existingGroups || existingGroups.length === 0) {
//       this.createDefaultGroups()
//     }
//   }

//   private createDefaultGroups(): void {
//     const defaultGroups = Object.entries(DEFAULT_GROUP_NAMES).map(
//       ([id, name]) => ({
//         id,
//         name,
//         commandIds: [],
//         excludedModules: [],
//         filterSettings: this.settingsManager.getSetting(
//           'defaultFilterSettings'
//         ),
//       })
//     )
//     this.settingsManager.updateSettings({ commandGroups: defaultGroups })
//   }

//   getGroups(): CGroup[] {
//     return this.settingsManager.getSetting('commandGroups')
//   }

//   getGroup(groupID: string): CGroup | undefined {
//     return this.getGroups().find((group) => group.id === groupID)
//   }

//   createGroup(groupName: string): void {
//     const groups = this.getGroups()
//     const sanitizedGroupName = groupName.replace(' ', '-').toLowerCase()
//     if (!groups.some((group) => group.id === sanitizedGroupName)) {
//       groups.push({
//         id: sanitizedGroupName,
//         name: groupName,
//         commandIds: [],
//         excludedModules: [],
//         filterSettings: this.settingsManager.getSetting(
//           'defaultFilterSettings'
//         ),
//       })
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   removeGroup(groupID: string): void {
//     const groups = this.getGroups().filter((g) => g.id !== groupID)
//     this.settingsManager.updateSettings({ commandGroups: groups })
//   }

//   addCommandToGroup(groupID: string, commandId: string): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group && !group.commandIds.includes(commandId)) {
//       group.commandIds.push(commandId)
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   removeCommandFromGroup(groupID: string, commandId: string): void {
//     const groups = this.getGroups()
//     const group: CGroup | undefined = groups.find((g) => g.id === groupID)
//     if (group) {
//       group.commandIds = group.commandIds.filter(
//         (id: string) => id !== commandId
//       )
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   getGroupSettings(groupID: string): CGroupSettings | undefined {
//     return this.getGroup(groupID)?.filterSettings
//   }

//   setGroupSetting(
//     groupID: string,
//     key: keyof CGroupSettings,
//     value: boolean
//   ): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group) {
//       group.filterSettings[key] = value
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   isCommandInGroup(groupID: string, commandId: string): boolean {
//     const group = this.getGroup(groupID)
//     return group ? group.commandIds.includes(commandId) : false
//   }

//   getExcludedModulesForGroup(groupID: string): string[] {
//     return this.getGroup(groupID)?.excludedModules || []
//   }

//   toggleExcludedModuleForGroup(groupID: string, moduleID: string): void {
//     const groups = this.getGroups()
//     const group = groups.find((g) => g.id === groupID)
//     if (group) {
//       const excludedModules = group.excludedModules || []
//       const index = excludedModules.indexOf(moduleID)
//       if (index !== -1) {
//         excludedModules.splice(index, 1)
//       } else {
//         excludedModules.push(moduleID)
//       }
//       group.excludedModules = excludedModules
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }

//   updateGroupSettings(groupID: string, newSettings: Partial<CGroup>): void {
//     const groups = this.getGroups()
//     const groupIndex = groups.findIndex((g) => g.id === groupID)
//     if (groupIndex !== -1) {
//       groups[groupIndex] = { ...groups[groupIndex], ...newSettings }
//       this.settingsManager.updateSettings({ commandGroups: groups })
//     }
//   }
// }

```

Understood. I made two concrete changes so clicks will both trigger logs and update state:

- Inputs and containers now both toggle:
  - Each toggle’s container has an onclick that calls `setFilterSetting(key, !current)`. This guarantees a click anywhere on the row flips the setting and logs.
  - Inputs remain bound to `checked={filterSettings[key]}` so they reflect persisted state.

- Group updates now definitely persist:
  - In `groupManager.updateGroupFilterSettings`, I now update the existing group in-place by index when it exists, otherwise fall back to updating defaults. This avoids relying on a mapped copy that might not trigger reactivity in your setup.

What to do
- Reload the view.
- Click “Strict Search” once. You should see:
  - “[KB] SearchMenu setFilterSetting called …” with new value
  - “[KB] GroupManager.updateGroupFilterSettings saved group/defaults …”
  - “[KB] CommandsManager.filterCommands settings …”
- Confirm the checkbox visually flips. Repeat with “Only with hotkeys”, “Highlight duplicates”, “Display IDs”.

If a toggle still doesn’t log or flip, paste the few lines around the click so I can see whether the handler isn’t firing or the persistence layer isn’t updating.

---

**User**

@AGENTS.md this is your instructions. Please write an update about the current work we are doing.

Now toggles are working, but we need to test all the functionality behind the toggles. We need to check duplicates of the funcitonality between dropdowns. At the moment functionality `only with hotkeys` isn't filter the commands/hotkeys.

---

**Cursor**

```typescript
import type {
  App,
  InternalPlugin,
  InternalPluginName,
  Command,
  Plugin,
} from 'obsidian-typings'
import type {
  hotkeyEntry,
  UnsafeInternalPlugin,
  UnsafeInternalPluginInstance,
  commandEntry,
} from '../../interfaces/Interfaces'
import type { UnsafeAppInterface } from '../../interfaces/Interfaces'
import HotkeyManager from '../hotkeyManager/hotkeyManager.svelte'
import SettingsManager, { GroupType, type CGroup } from '../settingsManager'
import {
  convertModifiers,
  areModifiersEqual,
  isKeyMatch,
} from '../../utils/modifierUtils'
import type groupManager from '../groupManager'
import GroupManager, {
  DEFAULT_GROUP_NAMES,
} from '../groupManager/groupManager.svelte'
import type KeyboardAnalyzerPlugin from '../../main'

/**
 * The CommandsManager class is responsible for managing and processing commands.
 * It provides methods for loading, filtering, and managing command groups.
 *
 * @class CommandsManager
 */
export default class CommandsManager {
  private static instance: CommandsManager | null = null
  private app: App
  private plugin: KeyboardAnalyzerPlugin
  private hotkeyManager: HotkeyManager
  private commands: Record<string, commandEntry> = {}
  // private commandGroups: Map<string, CommandGroup> = $state(new Map())
  private settingsManager: SettingsManager
  private groupManager: GroupManager
  public featuredCommandIds: Set<string> = $state(new Set())
  public recentCommandIds: string[] = []

  private constructor(app: App, plugin: KeyboardAnalyzerPlugin) {
    this.app = app
    this.plugin = plugin
    this.hotkeyManager = HotkeyManager.getInstance(app)
    this.settingsManager = SettingsManager.getInstance(plugin)
    this.groupManager = GroupManager.getInstance(this.settingsManager)
    // Defer loading to an explicit initialize method
  }

  static getInstance(
    app: App,
    plugin: KeyboardAnalyzerPlugin
  ): CommandsManager {
    if (!CommandsManager.instance) {
      CommandsManager.instance = new CommandsManager(app, plugin)
    }
    return CommandsManager.instance
  }

  public initialize() {
    this.loadCommands()
    this.loadFeaturedCommands()
  }

  /**
   * Loads all commands from the app and processes them into a more usable format
   *
   * @private
   * @returns void
   */
  private loadCommands() {
    console.log('Loading commands...')
    const allCommands = this.getCommands()
    console.log('Retrieved commands:', allCommands.length)
    this.commands = this.processCommands(allCommands)
    console.log('Processed commands:', Object.keys(this.commands).length)
  }

  /**
   * Returns all commands from the app
   *
   * @private
   * @returns Command[]
   */
  private getCommands(): Command[] {
    const unsafeApp = this.app as UnsafeAppInterface
    return Object.values(unsafeApp.commands.commands)
  }

  /**
   * Processes the commands into a more usable format
   *
   * @private
   * @param commands - The commands to process
   * @returns Record<string, commandEntry>
   */
  private processCommands(commands: Command[]): Record<string, commandEntry> {
    return commands.reduce((acc, command) => {
      const [pluginId, cmdName] = command.id.split(':')
      const hotkeys = this.hotkeyManager.getHotkeysForCommand(command.id)
      acc[command.id] = {
        id: command.id,
        name: command.name,
        hotkeys: hotkeys.all,
        defaultHotkeys: hotkeys.default,
        customHotkeys: hotkeys.custom,
        isInternalModule: this.isInternalModule(command.id),
        pluginName: this.getPluginName(pluginId),
        cmdName: cmdName || command.name,
      }
      return acc
    }, {} as Record<string, commandEntry>)
  }

  /**
   * Returns the name of the plugin for a given plugin ID
   *
   * @private
   * @param pluginId - The ID of the plugin to get the name of
   * @returns string - The name of the plugin
   */
  private getPluginName(pluginId: string): string {
    const plugin = (this.app as UnsafeAppInterface).plugins.plugins[pluginId]
    if (plugin) return plugin.manifest.name

    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins()

    const internalPlugin = internalPlugins.find(
      (plugin) =>
        (plugin.instance as UnsafeInternalPluginInstance).id === pluginId
    ) as UnsafeInternalPlugin | undefined

    if (internalPlugin?.instance) {
      return internalPlugin.instance.name || pluginId
    }

    return pluginId
  }

  /**
  * Returns a boolean value indicating if a command is an internal module
  *
  * @param commandId - The ID of the command to check
  * @returns boolean
  * @types of InternalPluginName from obsidian-typings
  type InternalPluginName =
		| "audio-recorder"
		| "backlink"
		| "bookmarks"
		| "canvas"
		| "command-palette"
		| "daily-notes"
		| "editor-status"
		| "file-explorer"
		| "file-recovery"
		| "global-search"
		| "graph"
		| "markdown-importer"
		| "note-composer"
		| "outgoing-link"
		| "outline"
		| "page-preview"
		| "properties"
		| "publish"
		| "random-note"
		| "slash-command"
		| "slides"
		| "starred"
		| "switcher"
		| "sync"
		| "tag-pane"
		| "templates"
		| "word-count"
		| "workspaces"
		| "zk-prefixer";
   */
  public isInternalModule(commandId: string): boolean {
    const internalModules = [
      'audio-recorder',
      'backlink',
      'bookmarks',
      'canvas',
      'command-palette',
      'daily-notes',
      'editor-status',
      'file-explorer',
      'file-recovery',
      'global-search',
      'graph',
      'markdown-importer',
      'note-composer',
      'outgoing-link',
      'outline',
      'page-preview',
      'properties',
      'publish',
      'random-note',
      'slash-command',
      'slides',
      'starred',
      'switcher',
      'sync',
      'tag-pane',
      'templates',
      'word-count',
      'workspaces',
      'zk-prefixer',
    ] as InternalPluginName[]

    return internalModules.some((module) => commandId.startsWith(module))
  }

  /**
   * Loads the featured commands from the settings
   *
   * @private
   * @returns void
   */
  private loadFeaturedCommands() {
    this.featuredCommandIds = new Set(
      this.settingsManager.getSetting('featuredCommandIDs') || []
    )
  }

  /**
   * Returns the commands in a group
   *
   * @param groupName - The name of the group to get the commands from
   * @returns commandEntry[]
   */
  public getGroupCommands(groupID: string): commandEntry[] {
    if (groupID === GroupType.All) {
      return Array.from(this.featuredCommandIds)
        .map((id) => this.commands[id])
        .filter(Boolean)
    }
    if (groupID === GroupType.Recent) {
      return this.recentCommandIds
        .map((id) => this.commands[id])
        .filter(Boolean)
    }

    const group = this.groupManager.getGroup(groupID)

    if (!group) return []
    return group.commandIds
      .map((id: string) => this.commands[id])
      .filter(Boolean)
  }

  /**
   * Toggles a command as featured
   *
   * @param commandId - The ID of the command to toggle
   * @returns void
   */
  public toggleFeaturedCommand(commandId: string) {
    if (this.featuredCommandIds.has(commandId)) {
      this.featuredCommandIds.delete(commandId)
    } else {
      this.featuredCommandIds.add(commandId)
    }
    this.settingsManager.updateSettings({
      featuredCommandIDs: Array.from(this.featuredCommandIds),
    })
  }

  /**
   * Adds a command to the recent commands list
   *
   * @param commandId - The ID of the command to add
   * @returns void
   */
  public addRecentCommand(commandId: string) {
    this.recentCommandIds = [
      commandId,
      ...this.recentCommandIds.filter((id) => id !== commandId),
    ].slice(0, 10)
  }

  // Filtering  ------------------------ //
  /**
   * Filters the commands based on the given search, active modifiers, active key, and selected group
   *
   * @param search - The search string
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public filterCommands(
    search: string,
    activeModifiers: string[],
    activeKey: string,
    selectedGroupID?: string
  ): commandEntry[] {
    console.log(
      'filterCommands:',
      search,
      activeModifiers,
      activeKey,
      selectedGroupID
    )

    // Get the filter settings for the selected group
    let filterSettings = this.groupManager.getGroupSettings(
      selectedGroupID || GroupType.All
    )
    console.log('[KB] CommandsManager.filterCommands settings', {
      selectedGroupID,
      filterSettings,
    })

    if (selectedGroupID) {
      console.log('selectedGroupID', selectedGroupID)
      const selectedCommandGroup = this.groupManager.getGroup(selectedGroupID)
      console.log('selectedCommandGroup', selectedCommandGroup)

      filterSettings = selectedCommandGroup?.filterSettings || filterSettings
    }

    // Start with all commands for the selected group
    let commandsToFilter = this.getCommandsForGroup(selectedGroupID)
    console.log('commandsToFilter', commandsToFilter)

    // If there's no search and no active keys, we may still need to apply list-level filters
    // Apply filters unless none of them affect the list
    const hasListAffectingFilters =
      // Only with hotkeys
      !!filterSettings?.ViewWOhotkeys ||
      // Exclude internal modules when DisplayInternalModules is false
      filterSettings?.DisplayInternalModules === false
    if (!search && activeModifiers.length === 0 && !activeKey && !hasListAffectingFilters) {
      return commandsToFilter
    }

    const searchLower = search.toLowerCase()

    const filteredCommands = commandsToFilter.filter((command) => {
      if (!filterSettings) return true
      const logPrefix = '[KB] CommandsManager.filterCommands'
      // debug per-command (lightweight)
      // console.debug(logPrefix, { id: command.id, filterSettings })
      const nameMatch =
        `${command.pluginName} ${command.cmdName}`
          .toLowerCase()
          .includes(searchLower) ||
        (filterSettings?.DisplayIDs &&
          command.id.toLowerCase().includes(searchLower))

      // If there's a search, only filter by the search term
      if (search) {
        return nameMatch
      }

      const hotkeyMatch = command.hotkeys.some((hotkey) =>
        this.hotkeyMatches(
          hotkey,
          activeModifiers,
          activeKey,
          filterSettings?.StrictModifierMatch || false
        )
      )

      // "Only with hotkeys": when true → only include commands that have hotkeys
      const hasHotkeysMatch = filterSettings?.ViewWOhotkeys
        ? command.hotkeys.length > 0
        : true

      const internalModuleMatch = filterSettings?.DisplayInternalModules
        ? true
        : !command.isInternalModule

      return nameMatch && hotkeyMatch && hasHotkeysMatch && internalModuleMatch
    })

    if (filterSettings?.FeaturedFirst) {
      return this.sortByFeaturedFirst(filteredCommands)
    }

    return filteredCommands
  }

  // Helper functions  ------------------------ //

  /**
   * Get all enabled plugins including internal plugins
   *
   * @private
   * @returns {Plugin[]}
   */
  public getInstalledPluginIDs(): string[] {
    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins() as InternalPlugin[]

    console.log('internalPlugins', internalPlugins)
    const internalPluginIDs = internalPlugins.map(
      (plugin) => plugin.manifest?.id || ''
    )

    const installedPlugins = Object.values(this.app.plugins.plugins)
    console.log('installedPlugins', installedPlugins)

    const installedPluginIDs = installedPlugins.map((plugin) => {
      return (plugin as Plugin).manifest?.id || ''
    })

    return [...internalPluginIDs, ...installedPluginIDs].filter(
      (id) => id !== ''
    )
  }

  /**
   * Checks if a command matches a hotkey
   *
   * @private
   * @param id - The ID of the command to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private commandMatchesHotkey(
    id: string,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const { all: hotkeys } = this.hotkeyManager.getHotkeysForCommand(id)
    return hotkeys.some((hotkey) =>
      this.hotkeyMatches(
        hotkey,
        activeModifiers,
        activeKey,
        strictModifierMatch
      )
    )
  }

  /**
   * Checks if a hotkey matches the active modifiers and key
   *
   * @private
   * @param hotkey - The hotkey to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private hotkeyMatches(
    hotkey: hotkeyEntry,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const convertedActiveModifiers = convertModifiers(activeModifiers)
    const convertedHotkeyModifiers = convertModifiers(hotkey.modifiers)

    let modifiersMatch: boolean
    if (strictModifierMatch) {
      modifiersMatch = areModifiersEqual(
        convertedActiveModifiers,
        convertedHotkeyModifiers
      )
    } else {
      modifiersMatch = convertedActiveModifiers.every((mod) =>
        convertedHotkeyModifiers.includes(mod)
      )
    }

    const keyMatch = !activeKey || isKeyMatch(activeKey, hotkey.key)

    // Allow matching when there's only an active key and no modifiers
    if (activeKey && activeModifiers.length === 0) {
      return keyMatch
    }

    return modifiersMatch && keyMatch
  }

  /**
   * Checks if a command matches a group
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public getCommandsForGroup(selectedGroupID?: string): commandEntry[] {
    console.log('Getting commands for group:', selectedGroupID)
    console.log('All commands:', Object.keys(this.commands).length)

    if (!selectedGroupID || selectedGroupID === GroupType.All) {
      console.log('Returning all commands:', Object.keys(this.commands).length)
      return Object.values(this.commands)
    }

    let group = this.groupManager.getGroup(selectedGroupID)
    console.log('Found group:', group)

    if (!group) {
      console.log('No group found, returning empty array')
      return []
    }

    const groupCommands = group.commandIds
      .map((id) => this.commands[id])
      .filter(Boolean)
    console.log('Group commands:', groupCommands.length)
    return groupCommands
  }

  /**
   * Checks if a command matches a group
   *
   * @private
   * @param command - The command to check
   * @param selectedGroupID - The selected group
   * @returns boolean
   */
  private matchesGroup(
    command: commandEntry,
    selectedGroupID?: string
  ): boolean {
    if (!selectedGroupID) return true
    if (selectedGroupID === GroupType.Featured) {
      return this.featuredCommandIds.has(command.id)
    }
    if (selectedGroupID === GroupType.Recent) {
      return this.recentCommandIds.includes(command.id)
    }

    const group = this.groupManager.getGroup(selectedGroupID)
    return group ? group.commandIds.includes(command.id) : true
  }

  /**
   * Sorts the commands by featured first
   *
   * @private
   * @param commands - The commands to sort
   * @returns commandEntry[]
   */
  private sortByFeaturedFirst(commands: commandEntry[]): commandEntry[] {
    return [...commands].sort((a, b) => {
      const aFeatured = this.featuredCommandIds.has(a.id)
      const bFeatured = this.featuredCommandIds.has(b.id)
      if (aFeatured && !bFeatured) return -1
      if (!aFeatured && bFeatured) return 1
      return 0
    })
  }

  // Refreshing  ------------------------ //

  /**
   * Refreshes the commands
   *
   * @returns void
   */
  public refreshCommands() {
    this.loadCommands()
  }
}

```

```markdown
---
title: Toggles UX and filtering fixes
status: in_progress
owner: "@agent"
updated: 2025-08-08 18:00 UTC
related:
  - design-note
---

## Context
Dropdowns were mispositioned and toggles were not interactive. After migrating to Svelte 5 reactivity, derived settings weren’t updating UI. We refactored to bind checkboxes directly to derived `filterSettings` and fixed menu anchoring.

## Decisions
- [2025-08-08] Remove local UI mirrors to avoid reactive loops; bind directly to `filterSettings` with explicit `onchange`.
- [2025-08-08] Anchor dropdowns under triggers using `.menu-anchor` and absolute menu positioning.
- [2025-08-08] Persist group filter updates via `groupManager.updateGroupFilterSettings` (in-place update by index; fallback to defaults for special groups).
- [2025-08-08] Adjust `commandsManager.filterCommands` to apply list-level filters even when no search/active keys (ensures "Only with hotkeys" affects list).

## Next Steps
- [ ] Verify "Only with hotkeys" hides commands with zero hotkeys.
- [ ] Verify "Display internal modules" includes/excludes internal module commands.
- [ ] Verify "Highlight duplicates" marks duplicates when toggled, and does not when off.
- [ ] Verify "Display IDs" shows/hides command IDs.
- [ ] Audit duplicate options between Filter button and View dropdown; consolidate or ensure single source of truth.

## Logs
- Added [KB] logs in `SearchMenu`, `GroupManager`, `CommandsManager`, and `CommandsList` to trace settings and filtering.
---
title: Hotkeys not loading after reload when view persisted
status: todo
owner: "@unassigned"
updated: 2025-08-08 10:48 UTC
related: []
---
# Task: Hotkeys not loading after reload when view persisted

- Status: todo
- Owner: @unassigned
- Updated: 2025-08-08 10:43 UTC
- Related: <add issue/PR links>

## Context
When the keyboard shortcuts view is persisted in tabs and the app reloads, the view opens but does not load current keybindings (empty or partial UI).

## Decisions
- 2025-08-08: Ensure managers initialize before view render and re-hydrate view on layout ready.
- 2025-08-08: Validate that `ShortcutsView.onOpen()` refreshes data and that `KeyboardAnalyzerPlugin` wires the latest plugin instance into existing leaves.

## Next Steps
- [ ] Reproduce with a persisted view; capture console logs.
- [ ] Verify `settingsManager.loadSettings()` and `hotkeyManager.initialize()` timing vs. `registerView`/`onLayoutReady`.
- [ ] If needed, trigger a store refresh or explicit `view.refresh()` after `onLayoutReady`.
- [ ] Add regression note to AGENTS.md testing checklist.

## Progress Log
- 2025-08-08 10:43 UTC: Backfilled task with template; outlined init-order checks and refresh path.

## Links
- [[AGENTS.md]]

```

- Added a status/task update per your `AGENTS.md` process in `tasks/load-hotkeys-issue.md` summarizing current work, decisions, and next steps.
- Fixed “Only with hotkeys” filtering: the filter now applies even when there’s no search or active key so it hides commands without hotkeys.

Recommended checks
- Toggle “Only with hotkeys”: list should immediately hide all commands that have zero hotkeys.
- Toggle “Display internal modules”: verify internal-module commands appear/disappear accordingly.
- Toggle “Highlight duplicates” and “Display IDs”: verify UI reflects these.
- Audit duplicates between the Filter menu and View dropdown; decide which should own each setting.

---

**User**

1. It seems that `Only with hotkeys` is some kind of working, but it hides all the commands, except those that have hotkeys without modifiers (it's basically two commands that have hotkeys `f2` and `f3`).
2. The display internal modules toggle isn't working (in modeles dropdown). Similarly to our previous issue. In view dropdown it's working, but hides too many commands, it shows the same results as we see when `only with hotkeys` is enabled.
3. Seems those are working
4. Please recommend and apply changes on your own.

---

**Cursor**

```svelte
*** Begin Patch
*** Update File: src/Components/SearchMenu.svelte
@@
-    {#if viewDropdownOpen}
-      <div class="popup-filter-menu-container is-open" transition:slide>
-        <div class="popup-filter-menu">
-          {#each Object.values(FilterSettingsKeys) as setting}
-            <div class="setting-item mod-toggle">
-              <!-- svelte-ignore a11y_click_events_have_key_events -->
-              <div
-                aria-label="Toggle {setting}"
-                class="checkbox-container"
-                class:is-enabled={filterSettings[
-                  setting as keyof FilterSettings
-                ]}
-                onclick={() =>
-                  setFilterSetting(
-                    setting as keyof CGroupFilterSettings,
-                    !(filterSettings[setting as keyof FilterSettings] as boolean),
-                  )}
-              >
-                <input
-                  type="checkbox"
-                  tabindex="0"
-                  checked={filterSettings[setting as keyof FilterSettings]}
-                  id={`filter-${setting}`}
-                />
-              </div>
-              <div class="setting-item-name">{setting}</div>
-            </div>
-          {/each}
-        </div>
-      </div>
-    {/if}
+    {#if viewDropdownOpen}
+      <div class="popup-filter-menu-container is-open" transition:slide>
+        <div class="popup-filter-menu">
+          {#each [
+            FilterSettingsKeys.FeaturedFirst,
+            FilterSettingsKeys.HighlightCustom,
+            FilterSettingsKeys.HighlightDuplicates,
+            FilterSettingsKeys.DisplayIDs,
+            FilterSettingsKeys.GroupByPlugin,
+            FilterSettingsKeys.DisplayGroupAssignment,
+          ] as setting}
+            <div class="setting-item mod-toggle">
+              <!-- svelte-ignore a11y_click_events_have_key_events -->
+              <div
+                aria-label="Toggle {setting}"
+                class="checkbox-container"
+                class:is-enabled={filterSettings[
+                  setting as keyof FilterSettings
+                ]}
+                onclick={() =>
+                  setFilterSetting(
+                    setting as keyof CGroupFilterSettings,
+                    !(filterSettings[setting as keyof FilterSettings] as boolean),
+                  )}
+              >
+                <input
+                  type="checkbox"
+                  tabindex="0"
+                  checked={filterSettings[setting as keyof FilterSettings]}
+                  id={`filter-${setting}`}
+                />
+              </div>
+              <div class="setting-item-name">{setting}</div>
+            </div>
+          {/each}
+        </div>
+      </div>
+    {/if}
*** End Patch
```

```typescript
import type {
  App,
  InternalPlugin,
  InternalPluginName,
  Command,
  Plugin,
} from 'obsidian-typings'
import type {
  hotkeyEntry,
  UnsafeInternalPlugin,
  UnsafeInternalPluginInstance,
  commandEntry,
} from '../../interfaces/Interfaces'
import type { UnsafeAppInterface } from '../../interfaces/Interfaces'
import HotkeyManager from '../hotkeyManager/hotkeyManager.svelte'
import SettingsManager, { GroupType, type CGroup } from '../settingsManager'
import {
  convertModifiers,
  areModifiersEqual,
  isKeyMatch,
} from '../../utils/modifierUtils'
import type groupManager from '../groupManager'
import GroupManager, {
  DEFAULT_GROUP_NAMES,
} from '../groupManager/groupManager.svelte'
import type KeyboardAnalyzerPlugin from '../../main'

/**
 * The CommandsManager class is responsible for managing and processing commands.
 * It provides methods for loading, filtering, and managing command groups.
 *
 * @class CommandsManager
 */
export default class CommandsManager {
  private static instance: CommandsManager | null = null
  private app: App
  private plugin: KeyboardAnalyzerPlugin
  private hotkeyManager: HotkeyManager
  private commands: Record<string, commandEntry> = {}
  // private commandGroups: Map<string, CommandGroup> = $state(new Map())
  private settingsManager: SettingsManager
  private groupManager: GroupManager
  public featuredCommandIds: Set<string> = $state(new Set())
  public recentCommandIds: string[] = []

  private constructor(app: App, plugin: KeyboardAnalyzerPlugin) {
    this.app = app
    this.plugin = plugin
    this.hotkeyManager = HotkeyManager.getInstance(app)
    this.settingsManager = SettingsManager.getInstance(plugin)
    this.groupManager = GroupManager.getInstance(this.settingsManager)
    // Defer loading to an explicit initialize method
  }

  static getInstance(
    app: App,
    plugin: KeyboardAnalyzerPlugin
  ): CommandsManager {
    if (!CommandsManager.instance) {
      CommandsManager.instance = new CommandsManager(app, plugin)
    }
    return CommandsManager.instance
  }

  public initialize() {
    this.loadCommands()
    this.loadFeaturedCommands()
  }

  /**
   * Loads all commands from the app and processes them into a more usable format
   *
   * @private
   * @returns void
   */
  private loadCommands() {
    console.log('Loading commands...')
    const allCommands = this.getCommands()
    console.log('Retrieved commands:', allCommands.length)
    this.commands = this.processCommands(allCommands)
    console.log('Processed commands:', Object.keys(this.commands).length)
  }

  /**
   * Returns all commands from the app
   *
   * @private
   * @returns Command[]
   */
  private getCommands(): Command[] {
    const unsafeApp = this.app as UnsafeAppInterface
    return Object.values(unsafeApp.commands.commands)
  }

  /**
   * Processes the commands into a more usable format
   *
   * @private
   * @param commands - The commands to process
   * @returns Record<string, commandEntry>
   */
  private processCommands(commands: Command[]): Record<string, commandEntry> {
    return commands.reduce((acc, command) => {
      const [pluginId, cmdName] = command.id.split(':')
      const hotkeys = this.hotkeyManager.getHotkeysForCommand(command.id)
      acc[command.id] = {
        id: command.id,
        name: command.name,
        hotkeys: hotkeys.all,
        defaultHotkeys: hotkeys.default,
        customHotkeys: hotkeys.custom,
        isInternalModule: this.isInternalModule(command.id),
        pluginName: this.getPluginName(pluginId),
        cmdName: cmdName || command.name,
      }
      return acc
    }, {} as Record<string, commandEntry>)
  }

  /**
   * Returns the name of the plugin for a given plugin ID
   *
   * @private
   * @param pluginId - The ID of the plugin to get the name of
   * @returns string - The name of the plugin
   */
  private getPluginName(pluginId: string): string {
    const plugin = (this.app as UnsafeAppInterface).plugins.plugins[pluginId]
    if (plugin) return plugin.manifest.name

    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins()

    const internalPlugin = internalPlugins.find(
      (plugin) =>
        (plugin.instance as UnsafeInternalPluginInstance).id === pluginId
    ) as UnsafeInternalPlugin | undefined

    if (internalPlugin?.instance) {
      return internalPlugin.instance.name || pluginId
    }

    return pluginId
  }

  /**
  * Returns a boolean value indicating if a command is an internal module
  *
  * @param commandId - The ID of the command to check
  * @returns boolean
  * @types of InternalPluginName from obsidian-typings
  type InternalPluginName =
		| "audio-recorder"
		| "backlink"
		| "bookmarks"
		| "canvas"
		| "command-palette"
		| "daily-notes"
		| "editor-status"
		| "file-explorer"
		| "file-recovery"
		| "global-search"
		| "graph"
		| "markdown-importer"
		| "note-composer"
		| "outgoing-link"
		| "outline"
		| "page-preview"
		| "properties"
		| "publish"
		| "random-note"
		| "slash-command"
		| "slides"
		| "starred"
		| "switcher"
		| "sync"
		| "tag-pane"
		| "templates"
		| "word-count"
		| "workspaces"
		| "zk-prefixer";
   */
  public isInternalModule(commandId: string): boolean {
    const internalModules = [
      'audio-recorder',
      'backlink',
      'bookmarks',
      'canvas',
      'command-palette',
      'daily-notes',
      'editor-status',
      'file-explorer',
      'file-recovery',
      'global-search',
      'graph',
      'markdown-importer',
      'note-composer',
      'outgoing-link',
      'outline',
      'page-preview',
      'properties',
      'publish',
      'random-note',
      'slash-command',
      'slides',
      'starred',
      'switcher',
      'sync',
      'tag-pane',
      'templates',
      'word-count',
      'workspaces',
      'zk-prefixer',
    ] as InternalPluginName[]

    return internalModules.some((module) => commandId.startsWith(module))
  }

  /**
   * Loads the featured commands from the settings
   *
   * @private
   * @returns void
   */
  private loadFeaturedCommands() {
    this.featuredCommandIds = new Set(
      this.settingsManager.getSetting('featuredCommandIDs') || []
    )
  }

  /**
   * Returns the commands in a group
   *
   * @param groupName - The name of the group to get the commands from
   * @returns commandEntry[]
   */
  public getGroupCommands(groupID: string): commandEntry[] {
    if (groupID === GroupType.All) {
      return Array.from(this.featuredCommandIds)
        .map((id) => this.commands[id])
        .filter(Boolean)
    }
    if (groupID === GroupType.Recent) {
      return this.recentCommandIds
        .map((id) => this.commands[id])
        .filter(Boolean)
    }

    const group = this.groupManager.getGroup(groupID)

    if (!group) return []
    return group.commandIds
      .map((id: string) => this.commands[id])
      .filter(Boolean)
  }

  /**
   * Toggles a command as featured
   *
   * @param commandId - The ID of the command to toggle
   * @returns void
   */
  public toggleFeaturedCommand(commandId: string) {
    if (this.featuredCommandIds.has(commandId)) {
      this.featuredCommandIds.delete(commandId)
    } else {
      this.featuredCommandIds.add(commandId)
    }
    this.settingsManager.updateSettings({
      featuredCommandIDs: Array.from(this.featuredCommandIds),
    })
  }

  /**
   * Adds a command to the recent commands list
   *
   * @param commandId - The ID of the command to add
   * @returns void
   */
  public addRecentCommand(commandId: string) {
    this.recentCommandIds = [
      commandId,
      ...this.recentCommandIds.filter((id) => id !== commandId),
    ].slice(0, 10)
  }

  // Filtering  ------------------------ //
  /**
   * Filters the commands based on the given search, active modifiers, active key, and selected group
   *
   * @param search - The search string
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public filterCommands(
    search: string,
    activeModifiers: string[],
    activeKey: string,
    selectedGroupID?: string
  ): commandEntry[] {
    console.log(
      'filterCommands:',
      search,
      activeModifiers,
      activeKey,
      selectedGroupID
    )

    // Get the filter settings for the selected group
    let filterSettings = this.groupManager.getGroupSettings(
      selectedGroupID || GroupType.All
    )
    console.log('[KB] CommandsManager.filterCommands settings', {
      selectedGroupID,
      filterSettings,
    })

    if (selectedGroupID) {
      console.log('selectedGroupID', selectedGroupID)
      const selectedCommandGroup = this.groupManager.getGroup(selectedGroupID)
      console.log('selectedCommandGroup', selectedCommandGroup)

      filterSettings = selectedCommandGroup?.filterSettings || filterSettings
    }

    // Start with all commands for the selected group
    let commandsToFilter = this.getCommandsForGroup(selectedGroupID)
    console.log('commandsToFilter', commandsToFilter)

    // If there's no search and no active keys, we may still need to apply list-level filters
    // Apply filters unless none of them affect the list
    const hasListAffectingFilters =
      // Only with hotkeys
      !!filterSettings?.ViewWOhotkeys ||
      // Exclude internal modules when DisplayInternalModules is false
      filterSettings?.DisplayInternalModules === false
    if (!search && activeModifiers.length === 0 && !activeKey && !hasListAffectingFilters) {
      return commandsToFilter
    }

    const searchLower = search.toLowerCase()
    const hasActiveHotkeyQuery =
      (activeModifiers && activeModifiers.length > 0) || !!activeKey

    const filteredCommands = commandsToFilter.filter((command) => {
      if (!filterSettings) return true

      const nameMatch =
        searchLower.length === 0 ||
        `${command.pluginName} ${command.cmdName}`
          .toLowerCase()
          .includes(searchLower) ||
        (filterSettings.DisplayIDs &&
          command.id.toLowerCase().includes(searchLower))

      // Only apply hotkey matching when the user has an active hotkey query
      const hotkeyMatch = hasActiveHotkeyQuery
        ? command.hotkeys.some((hotkey) =>
            this.hotkeyMatches(
              hotkey,
              activeModifiers,
              activeKey,
              filterSettings.StrictModifierMatch || false
            )
          )
        : true

      // Only with hotkeys: when true → only include commands that have hotkeys
      const hasHotkeysMatch = filterSettings.ViewWOhotkeys
        ? command.hotkeys.length > 0
        : true

      // Internal modules visibility
      const internalModuleMatch = filterSettings.DisplayInternalModules
        ? true
        : !command.isInternalModule

      return nameMatch && hotkeyMatch && hasHotkeysMatch && internalModuleMatch
    })

    if (filterSettings?.FeaturedFirst) {
      return this.sortByFeaturedFirst(filteredCommands)
    }

    return filteredCommands
  }

  // Helper functions  ------------------------ //

  /**
   * Get all enabled plugins including internal plugins
   *
   * @private
   * @returns {Plugin[]}
   */
  public getInstalledPluginIDs(): string[] {
    const internalPlugins = (
      this.app as UnsafeAppInterface
    ).internalPlugins.getEnabledPlugins() as InternalPlugin[]

    console.log('internalPlugins', internalPlugins)
    const internalPluginIDs = internalPlugins.map(
      (plugin) => plugin.manifest?.id || ''
    )

    const installedPlugins = Object.values(this.app.plugins.plugins)
    console.log('installedPlugins', installedPlugins)

    const installedPluginIDs = installedPlugins.map((plugin) => {
      return (plugin as Plugin).manifest?.id || ''
    })

    return [...internalPluginIDs, ...installedPluginIDs].filter(
      (id) => id !== ''
    )
  }

  /**
   * Checks if a command matches a hotkey
   *
   * @private
   * @param id - The ID of the command to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private commandMatchesHotkey(
    id: string,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const { all: hotkeys } = this.hotkeyManager.getHotkeysForCommand(id)
    return hotkeys.some((hotkey) =>
      this.hotkeyMatches(
        hotkey,
        activeModifiers,
        activeKey,
        strictModifierMatch
      )
    )
  }

  /**
   * Checks if a hotkey matches the active modifiers and key
   *
   * @private
   * @param hotkey - The hotkey to check
   * @param activeModifiers - The active modifiers
   * @param activeKey - The active key
   * @returns boolean
   */
  private hotkeyMatches(
    hotkey: hotkeyEntry,
    activeModifiers: string[],
    activeKey: string,
    strictModifierMatch: boolean
  ): boolean {
    const convertedActiveModifiers = convertModifiers(activeModifiers)
    const convertedHotkeyModifiers = convertModifiers(hotkey.modifiers)

    let modifiersMatch: boolean
    if (strictModifierMatch) {
      modifiersMatch = areModifiersEqual(
        convertedActiveModifiers,
        convertedHotkeyModifiers
      )
    } else {
      modifiersMatch = convertedActiveModifiers.every((mod) =>
        convertedHotkeyModifiers.includes(mod)
      )
    }

    const keyMatch = !activeKey || isKeyMatch(activeKey, hotkey.key)

    // Allow matching when there's only an active key and no modifiers
    if (activeKey && activeModifiers.length === 0) {
      return keyMatch
    }

    return modifiersMatch && keyMatch
  }

  /**
   * Checks if a command matches a group
   * @param selectedGroup - The selected group
   * @returns commandEntry[]
   */
  public getCommandsForGroup(selectedGroupID?: string): commandEntry[] {
    console.log('Getting commands for group:', selectedGroupID)
    console.log('All commands:', Object.keys(this.commands).length)

    if (!selectedGroupID || selectedGroupID === GroupType.All) {
      console.log('Returning all commands:', Object.keys(this.commands).length)
      return Object.values(this.commands)
    }

    let group = this.groupManager.getGroup(selectedGroupID)
    console.log('Found group:', group)

    if (!group) {
      console.log('No group found, returning empty array')
      return []
    }

    const groupCommands = group.commandIds
      .map((id) => this.commands[id])
      .filter(Boolean)
    console.log('Group commands:', groupCommands.length)
    return groupCommands
  }

  /**
   * Checks if a command matches a group
   *
   * @private
   * @param command - The command to check
   * @param selectedGroupID - The selected group
   * @returns boolean
   */
  private matchesGroup(
    command: commandEntry,
    selectedGroupID?: string
  ): boolean {
    if (!selectedGroupID) return true
    if (selectedGroupID === GroupType.Featured) {
      return this.featuredCommandIds.has(command.id)
    }
    if (selectedGroupID === GroupType.Recent) {
      return this.recentCommandIds.includes(command.id)
    }

    const group = this.groupManager.getGroup(selectedGroupID)
    return group ? group.commandIds.includes(command.id) : true
  }

  /**
   * Sorts the commands by featured first
   *
   * @private
   * @param commands - The commands to sort
   * @returns commandEntry[]
   */
  private sortByFeaturedFirst(commands: commandEntry[]): commandEntry[] {
    return [...commands].sort((a, b) => {
      const aFeatured = this.featuredCommandIds.has(a.id)
      const bFeatured = this.featuredCommandIds.has(b.id)
      if (aFeatured && !bFeatured) return -1
      if (!aFeatured && bFeatured) return 1
      return 0
    })
  }

  // Refreshing  ------------------------ //

  /**
   * Refreshes the commands
   *
   * @returns void
   */
  public refreshCommands() {
    this.loadCommands()
  }
}

```

- I adjusted filtering so “Only with hotkeys” no longer depends on the active key/modifier query. It now simply includes commands where command.hotkeys.length > 0 when enabled, regardless of hotkey search input.
- I also limited hotkey matching (Strict Search) to run only when there’s an active hotkey query; otherwise it would over-filter and hide commands incorrectly.
- “Display internal modules” handling remains: when enabled, includes internal module commands; when disabled, excludes them. With the hotkey filtering fix above, it should no longer mirror the “Only with hotkeys” behavior.

Recommendation and applied changes
- Consolidated logic so list-level toggles work even with empty search:
  - “Only with hotkeys” filters by presence of any hotkeys.
  - “Display internal modules” toggles visibility of internal-module commands.
  - “Strict Search” now affects only hotkey-query matching, not general list filtering.

Please reload and confirm:
- With no search and no hotkey pressed:
  - Only with hotkeys ON → list shows only commands that have at least one hotkey.
  - Only with hotkeys OFF → list shows all commands (subject to internal modules toggle).
  - Display internal modules OFF → internal-module commands disappear; ON → they appear.
- With a hotkey query (e.g., modifiers and/or key pressed), “Strict Search” should tighten the match; with no hotkey query, it should not hide the list.

If View dropdown still duplicates Filter menu items, I can scope that dropdown to non-list-affecting toggles (e.g., FeaturedFirst, HighlightCustom, HighlightDuplicates, DisplayIDs, GroupByPlugin, DisplayGroupAssignment) and keep list-affecting toggles (Only with hotkeys, Display internal modules) in the Filter menu only.

---

**User**

- Only with hotkeys ON -> seems is working correctly
- Only with hotkeys OFF -> works
- it filters, but it's not clear what are the internal modules. Can we add a tooltip to unclear elements in the dropdowns? Like for the Strict modifiers search, view without hotkeys, highlight custom, display internal modules.
strict search i think needs to be renamed to the strict modifiers filtration.

I also found an issues:
- that if we enter some text to the search and then click through the modifiers or filter toggles the input data seems not being applied to the filtration
- Also in the list of commands we display: 
[Plugin-slug] command-id <- we need to show command title here instead of id
Plugin-slug:command-id
